<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë©€í‹°í”Œë ˆì´ì–´ ëª¬ìŠ¤í„° í”¼í•˜ê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0c1445, #1a237e);
            font-family: 'Courier New', monospace;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            background: radial-gradient(circle at center, #000428, #004e92);
            border: 2px solid #00ff41;
            display: block;
            margin: 0 auto;
        }

        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ff41;
        }

        .player-list {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ff41;
            min-width: 200px;
        }

        .join-form {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #00ff41;
            text-align: center;
            z-index: 20;
        }

        input[type="text"] {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff41;
            color: #00ff00;
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            font-family: inherit;
        }

        button {
            background: linear-gradient(45deg, #004e92, #000428);
            border: 2px solid #00ff41;
            color: #00ff00;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            font-family: inherit;
            margin: 5px;
            transition: all 0.3s;
        }

        button:hover {
            background: linear-gradient(45deg, #006bb3, #001845);
            box-shadow: 0 0 10px #00ff41;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #ff4444;
            text-align: center;
            z-index: 20;
            display: none;
        }

        .instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ff41;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="join-form" id="joinForm">
            <h2>ë©€í‹°í”Œë ˆì´ì–´ ëª¬ìŠ¤í„° í”¼í•˜ê¸°</h2>
            <p>ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”</p>
            <input type="text" id="playerName" placeholder="ë‹‰ë„¤ì„" maxlength="15">
            <br>
            <button onclick="joinGame()">ê²Œì„ ì°¸ê°€</button>
        </div>

        <div class="ui" id="gameUI" style="display: none;">
            <div>ìƒì¡´ ì‹œê°„: <span id="timeDisplay">0</span>ì´ˆ</div>
            <div>ëª¬ìŠ¤í„° ìˆ˜: <span id="observerCount">0</span></div>
            <div>ë‚´ ì ìˆ˜: <span id="myScore">0</span></div>
        </div>

        <div class="player-list" id="playerList" style="display: none;">
            <h3>í”Œë ˆì´ì–´ ëª©ë¡</h3>
            <div id="players"></div>
        </div>

        <canvas id="gameCanvas" style="display: none;"></canvas>

        <div class="game-over" id="gameOver">
            <h2>ê²Œì„ ì˜¤ë²„!</h2>
            <p id="finalScore"></p>
            <button onclick="respawn()">ë‹¤ì‹œ ì‹œì‘</button>
        </div>

        <div class="instructions" id="instructions" style="display: none;">
            í™”ì‚´í‘œ í‚¤ ë˜ëŠ” WASDë¡œ ì´ë™ â€¢ ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ì´ ë°œì‚¬ â€¢ ëª¬ìŠ¤í„°ë¥¼ í”¼í•˜ì„¸ìš”! â€¢ ë‹¤ë¥¸ í”Œë ˆì´ì–´ì™€ ë¶€ë”ªíˆë©´ ê¸°ì ˆ!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ê²Œì„ ìƒíƒœ
        let gameState = {
            players: new Map(),
            monsters: [],
            bullets: [],
            myPlayerId: null,
            gameStartTime: Date.now(),
            lastMonsterSpawn: 0,
            keys: {},
            gameRunning: false,
            camera: { x: 0, y: 0 },
            mapSize: { width: 2000, height: 2000 },
            lastSpacePress: 0
        };

        // í”Œë ˆì´ì–´ í´ë˜ìŠ¤
        class Player {
            constructor(id, name, x, y, color) {
                this.id = id;
                this.name = name;
                this.x = x;
                this.y = y;
                this.color = color;
                this.alive = true;
                this.score = 0;
                this.size = 8;
                this.speed = 3;
                this.invulnerable = false;
                this.invulnerabilityStart = 0;
                this.stunned = false;
                this.stunStart = 0;
                this.bullets = 0;
                this.lastX = x;
                this.lastY = y;
            }

            update() {
                if (!this.alive) return;

                this.lastX = this.x;
                this.lastY = this.y;

                // ê¸°ì ˆ ìƒíƒœ ì²´í¬
                if (this.stunned && Date.now() - this.stunStart > 100) {
                    this.stunned = false;
                }

                // í‚¤ ì…ë ¥ ì²˜ë¦¬ (ìì‹ ì˜ í”Œë ˆì´ì–´ë§Œ, ê¸°ì ˆ ì¤‘ì´ ì•„ë‹ ë•Œ)
                if (this.id === gameState.myPlayerId && !this.stunned) {
                    let moved = false;
                    if (gameState.keys['ArrowUp'] || gameState.keys['KeyW']) {
                        this.y -= this.speed;
                        moved = true;
                    }
                    if (gameState.keys['ArrowDown'] || gameState.keys['KeyS']) {
                        this.y += this.speed;
                        moved = true;
                    }
                    if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) {
                        this.x -= this.speed;
                        moved = true;
                    }
                    if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) {
                        this.x += this.speed;
                        moved = true;
                    }

                    // ì´ì•Œ ë°œì‚¬ (ìŠ¤í˜ì´ìŠ¤ë°”)
                    if (gameState.keys['Space'] && this.bullets > 0 &&
                        Date.now() - gameState.lastSpacePress > 200) {
                        this.shootBullet();
                        gameState.lastSpacePress = Date.now();
                    }

                    // ë§µ í™•ì¥
                    if (moved) {
                        const expandMargin = 200;
                        if (this.x > gameState.mapSize.width - expandMargin) {
                            gameState.mapSize.width = this.x + expandMargin;
                        }
                        if (this.y > gameState.mapSize.height - expandMargin) {
                            gameState.mapSize.height = this.y + expandMargin;
                        }
                        if (this.x < expandMargin) {
                            gameState.mapSize.width += expandMargin - this.x;
                            const offset = expandMargin - this.x;
                            gameState.players.forEach(p => p.x += offset);
                            gameState.monsters.forEach(m => m.x += offset);
                            gameState.bullets.forEach(b => b.x += offset);
                            gameState.camera.x += offset;
                        }
                        if (this.y < expandMargin) {
                            gameState.mapSize.height += expandMargin - this.y;
                            const offset = expandMargin - this.y;
                            gameState.players.forEach(p => p.y += offset);
                            gameState.monsters.forEach(m => m.y += offset);
                            gameState.bullets.forEach(b => b.y += offset);
                            gameState.camera.y += offset;
                        }
                    }
                }

                // ë¬´ì  ì‹œê°„ ì²´í¬
                if (this.invulnerable && Date.now() - this.invulnerabilityStart > 3000) {
                    this.invulnerable = false;
                }

                // ì ìˆ˜ ë° ì´ì•Œ ê³„ì‚°
                this.score = Math.floor((Date.now() - gameState.gameStartTime) / 100);
                this.bullets = Math.floor(this.score / 1000);
            }

            shootBullet() {
                if (this.bullets <= 0) return;

                // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸° (ë‹¤ë¥¸ í”Œë ˆì´ì–´ë‚˜ ëª¬ìŠ¤í„°)
                let closestTarget = null;
                let closestDistance = Infinity;

                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ ì²´í¬
                gameState.players.forEach(player => {
                    if (player.id !== this.id && player.alive) {
                        const distance = Math.sqrt(
                            Math.pow(player.x - this.x, 2) +
                            Math.pow(player.y - this.y, 2)
                        );
                        if (distance < closestDistance && distance < 200) {
                            closestDistance = distance;
                            closestTarget = player;
                        }
                    }
                });

                // ëª¬ìŠ¤í„°ë“¤ ì²´í¬
                gameState.monsters.forEach(monster => {
                    const distance = Math.sqrt(
                        Math.pow(monster.x - this.x, 2) +
                        Math.pow(monster.y - this.y, 2)
                    );
                    if (distance < closestDistance && distance < 200) {
                        closestDistance = distance;
                        closestTarget = monster;
                    }
                });

                if (closestTarget) {
                    const angle = Math.atan2(closestTarget.y - this.y, closestTarget.x - this.x);
                    gameState.bullets.push(new Bullet(this.x, this.y, angle, this.id));
                    this.bullets--;
                }
            }

            draw() {
                const screenX = this.x - gameState.camera.x + canvas.width / 2;
                const screenY = this.y - gameState.camera.y + canvas.height / 2;

                // ë¬´ì  ìƒíƒœì¼ ë•Œ ê¹œë¹¡ì„ íš¨ê³¼
                if (this.invulnerable) {
                    const blinkSpeed = 200;
                    const isVisible = Math.floor(Date.now() / blinkSpeed) % 2 === 0;
                    if (!isVisible) return;
                }

                // ê¸°ì ˆ ìƒíƒœ íš¨ê³¼
                if (this.stunned) {
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.sin(Date.now() * 0.05) * 0.2);
                    ctx.translate(-screenX, -screenY);
                }

                // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
                ctx.fillStyle = this.alive ? this.color : '#666666';
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();

                // í…Œë‘ë¦¬
                ctx.strokeStyle = this.alive ? '#ffffff' : '#333333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // ê¸°ì ˆ ìƒíƒœ í‘œì‹œ
                if (this.stunned) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('â­', screenX, screenY + 5);
                    ctx.restore();
                }

                // ë¬´ì  ìƒíƒœ í‘œì‹œ
                if (this.invulnerable) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // ì´ë¦„ í‘œì‹œ
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, screenX, screenY - 15);

                // ì´ì•Œ ê°œìˆ˜ í‘œì‹œ
                if (this.bullets > 0) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '10px Courier New';
                    ctx.fillText(`ğŸ”«${this.bullets}`, screenX, screenY + 20);
                }

                // ì£½ì€ í”Œë ˆì´ì–´ í‘œì‹œ
                if (!this.alive) {
                    ctx.fillStyle = '#ff4444';
                    ctx.font = '16px Courier New';
                    ctx.fillText('ğŸ’€', screenX, screenY + 5);
                }
            }
        }

        // ëª¬ìŠ¤í„° ë² ì´ìŠ¤ í´ë˜ìŠ¤
        class Monster {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.alive = true;
                this.stunned = false;
                this.stunStart = 0;
                this.angle = 0;
            }

            update() {
                if (!this.alive) return;

                // ê¸°ì ˆ ìƒíƒœ ì²´í¬
                if (this.stunned && Date.now() - this.stunStart > 2000) {
                    this.stunned = false;
                }

                if (!this.stunned) {
                    this.ai();
                }

                this.angle += 0.1;
            }

            ai() {
                // ê° ëª¬ìŠ¤í„° íƒ€ì…ë³„ë¡œ ì˜¤ë²„ë¼ì´ë“œ
            }

            draw() {
                const screenX = this.x - gameState.camera.x + canvas.width / 2;
                const screenY = this.y - gameState.camera.y + canvas.height / 2;

                // í™”ë©´ ë°–ì´ë©´ ê·¸ë¦¬ì§€ ì•ŠìŒ
                if (screenX < -50 || screenX > canvas.width + 50 ||
                    screenY < -50 || screenY > canvas.height + 50) {
                    return;
                }

                if (this.stunned) {
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.sin(Date.now() * 0.02) * 0.3);
                    ctx.translate(-screenX, -screenY);
                    ctx.fillStyle = '#666666';
                } else {
                    ctx.fillStyle = this.color;
                }

                this.drawShape(screenX, screenY);

                if (this.stunned) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('ğŸ’«', screenX, screenY - 20);
                    ctx.restore();
                }
            }
        }

        // ì˜µì €ë²„ (ì¶”ì í˜•)
        class Observer extends Monster {
            constructor(x, y) {
                super(x, y, 'observer');
                this.size = 15;
                this.speed = 1.5;
                this.color = '#ff6600';
            }

            ai() {
                // ê°€ì¥ ê°€ê¹Œìš´ ì‚´ì•„ìˆëŠ” í”Œë ˆì´ì–´ë¥¼ ì¶”ì 
                let closestPlayer = null;
                let closestDistance = Infinity;

                gameState.players.forEach(player => {
                    if (player.alive && !player.invulnerable) {
                        const distance = Math.sqrt(
                            Math.pow(player.x - this.x, 2) +
                            Math.pow(player.y - this.y, 2)
                        );
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestPlayer = player;
                        }
                    }
                });

                if (closestPlayer) {
                    const dx = closestPlayer.x - this.x;
                    const dy = closestPlayer.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                }
            }

            drawShape(screenX, screenY) {
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.angle);

                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#ffaa44';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * this.size, Math.sin(angle) * this.size);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // ëŸ¬ì…” (ë¹ ë¥¸ ëŒì§„í˜•)
        class Rusher extends Monster {
            constructor(x, y) {
                super(x, y, 'rusher');
                this.size = 10;
                this.speed = 4;
                this.color = '#ff3333';
                this.rushTarget = null;
                this.rushCooldown = 0;
            }

            ai() {
                const now = Date.now();

                if (now - this.rushCooldown > 3000) {
                    // ìƒˆë¡œìš´ íƒ€ê²Ÿ ì°¾ê¸°
                    let closestPlayer = null;
                    let closestDistance = Infinity;

                    gameState.players.forEach(player => {
                        if (player.alive) {
                            const distance = Math.sqrt(
                                Math.pow(player.x - this.x, 2) +
                                Math.pow(player.y - this.y, 2)
                            );
                            if (distance < closestDistance && distance < 300) {
                                closestDistance = distance;
                                closestPlayer = player;
                            }
                        }
                    });

                    if (closestPlayer) {
                        this.rushTarget = { x: closestPlayer.x, y: closestPlayer.y };
                        this.rushCooldown = now;
                    }
                }

                if (this.rushTarget) {
                    const dx = this.rushTarget.x - this.x;
                    const dy = this.rushTarget.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 5) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    } else {
                        this.rushTarget = null;
                    }
                }
            }

            drawShape(screenX, screenY) {
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();

                // ìŠ¤íŒŒì´í¬ë“¤
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + this.angle;
                    const startX = screenX + Math.cos(angle) * this.size;
                    const startY = screenY + Math.sin(angle) * this.size;
                    const endX = screenX + Math.cos(angle) * (this.size + 5);
                    const endY = screenY + Math.sin(angle) * (this.size + 5);

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            }
        }

        // íŒ¨íŠ¸ë¡¤ëŸ¬ (ìˆœì°°í˜•)
        class Patroller extends Monster {
            constructor(x, y) {
                super(x, y, 'patroller');
                this.size = 12;
                this.speed = 2;
                this.color = '#9933ff';
                this.patrolTarget = { x: x + Math.random() * 200 - 100, y: y + Math.random() * 200 - 100 };
                this.patrolRadius = 150;
                this.centerX = x;
                this.centerY = y;
            }

            ai() {
                // ìˆœì°° ì§€ì ìœ¼ë¡œ ì´ë™
                const dx = this.patrolTarget.x - this.x;
                const dy = this.patrolTarget.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 20) {
                    // ìƒˆë¡œìš´ ìˆœì°° ì§€ì  ì„¤ì •
                    const angle = Math.random() * Math.PI * 2;
                    this.patrolTarget = {
                        x: this.centerX + Math.cos(angle) * this.patrolRadius,
                        y: this.centerY + Math.sin(angle) * this.patrolRadius
                    };
                } else {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
            }

            drawShape(screenX, screenY) {
                // ì‚¬ê°í˜• ëª¸ì²´
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.angle);

                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);

                // ì¤‘ì•™ ì 
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // ì´ì•Œ í´ë˜ìŠ¤
        class Bullet {
            constructor(x, y, angle, shooterId) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 8;
                this.shooterId = shooterId;
                this.size = 3;
                this.life = 1000; // 1ì´ˆ í›„ ì†Œë©¸
                this.createTime = Date.now();
            }

            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                // ìˆ˜ëª… ì²´í¬
                if (Date.now() - this.createTime > this.life) {
                    return false; // ì œê±° ì‹ í˜¸
                }

                return true;
            }

            draw() {
                const screenX = this.x - gameState.camera.x + canvas.width / 2;
                const screenY = this.y - gameState.camera.y + canvas.height / 2;

                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();

                // ê¼¬ë¦¬ íš¨ê³¼
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(
                    screenX - Math.cos(this.angle) * 10,
                    screenY - Math.sin(this.angle) * 10
                );
                ctx.stroke();
            }
        }

        // ê²Œì„ ì°¸ê°€
        function joinGame() {
            const nameInput = document.getElementById('playerName');
            const name = nameInput.value.trim();

            if (!name) {
                alert('ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”!');
                return;
            }

            // UI ì „í™˜
            document.getElementById('joinForm').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('gameUI').style.display = 'block';
            document.getElementById('playerList').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';

            // í”Œë ˆì´ì–´ ìƒì„±
            const playerId = 'player_' + Date.now() + '_' + Math.random();
            const playerColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
            const startX = Math.random() * (canvas.width - 100) + 50;
            const startY = Math.random() * (canvas.height - 100) + 50;

            const player = new Player(playerId, name, startX, startY, playerColor);
            gameState.players.set(playerId, player);
            gameState.myPlayerId = playerId;
            gameState.gameRunning = true;
            gameState.gameStartTime = Date.now();

            // ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œ ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” ì„œë²„ì—ì„œ ê´€ë¦¬)
            addRandomPlayers();

            // ê²Œì„ ë£¨í”„ ì‹œì‘
            gameLoop();
        }

        // ëœë¤ í”Œë ˆì´ì–´ ì¶”ê°€ (ì‹œë®¬ë ˆì´ì…˜)
        function addRandomPlayers() {
            const botNames = ['AIì „ì‚¬', 'ë¡œë´‡íŒŒì¼ëŸ¿', 'ì‚¬ì´ë²„ë‹Œì', 'ë””ì§€í„¸í—Œí„°', 'ë„¤ì˜¨ëŸ¬ë„ˆ'];

            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const botId = 'bot_' + i + '_' + Date.now();
                    const botName = botNames[i] + (Math.floor(Math.random() * 100));
                    const botColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
                    const startX = Math.random() * (canvas.width - 100) + 50;
                    const startY = Math.random() * (canvas.height - 100) + 50;

                    const bot = new Player(botId, botName, startX, startY, botColor);
                    gameState.players.set(botId, bot);
                    updatePlayerList();
                }, i * 2000);
            }
        }

        // AI í”Œë ˆì´ì–´ ì´ë™ (ì‹œë®¬ë ˆì´ì…˜)
        function updateBots() {
            gameState.players.forEach(player => {
                if (player.id !== gameState.myPlayerId && player.alive && !player.stunned) {
                    // ê°€ì¥ ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ì°¾ê¸°
                    let closestMonster = null;
                    let closestDistance = Infinity;

                    gameState.monsters.forEach(monster => {
                        if (!monster.stunned) {
                            const distance = Math.sqrt(
                                Math.pow(monster.x - player.x, 2) +
                                Math.pow(monster.y - player.y, 2)
                            );
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestMonster = monster;
                            }
                        }
                    });

                    // ëª¬ìŠ¤í„°ê°€ ê°€ê¹Œìš°ë©´ ë„ë§
                    if (closestMonster && closestDistance < 80) {
                        const dx = player.x - closestMonster.x;
                        const dy = player.y - closestMonster.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 0) {
                            player.x += (dx / distance) * player.speed;
                            player.y += (dy / distance) * player.speed;
                        }
                    } else {
                        // ëœë¤ ì´ë™
                        if (Math.random() < 0.02) {
                            const angle = Math.random() * Math.PI * 2;
                            player.x += Math.cos(angle) * player.speed;
                            player.y += Math.sin(angle) * player.speed;
                        }
                    }

                    // ë´‡ ì´ì•Œ ë°œì‚¬ (ê°€ë”)
                    if (Math.random() < 0.005 && player.bullets > 0) {
                        // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
                        let closestTarget = null;
                        let closestTargetDistance = Infinity;

                        gameState.players.forEach(otherPlayer => {
                            if (otherPlayer.id !== player.id && otherPlayer.alive) {
                                const distance = Math.sqrt(
                                    Math.pow(otherPlayer.x - player.x, 2) +
                                    Math.pow(otherPlayer.y - player.y, 2)
                                );
                                if (distance < closestTargetDistance && distance < 150) {
                                    closestTargetDistance = distance;
                                    closestTarget = otherPlayer;
                                }
                            }
                        });

                        if (closestTarget) {
                            const angle = Math.atan2(closestTarget.y - player.y, closestTarget.x - player.x);
                            gameState.bullets.push(new Bullet(player.x, player.y, angle, player.id));
                            player.bullets--;
                        }
                    }
                }
            });
        }

        // ëª¬ìŠ¤í„° ìŠ¤í°
        function spawnMonster() {
            const now = Date.now();
            const timeSinceStart = (now - gameState.gameStartTime) / 1000;
            const spawnInterval = Math.max(2000 - (timeSinceStart * 50), 500);

            if (now - gameState.lastMonsterSpawn > spawnInterval) {
                const myPlayer = gameState.players.get(gameState.myPlayerId);
                if (!myPlayer) return;

                const spawnDistance = 300;
                const angle = Math.random() * Math.PI * 2;
                const x = myPlayer.x + Math.cos(angle) * spawnDistance;
                const y = myPlayer.y + Math.sin(angle) * spawnDistance;

                // ëœë¤ ëª¬ìŠ¤í„° íƒ€ì… ìƒì„±
                const monsterTypes = [Observer, Rusher, Patroller];
                const weights = [0.5, 0.3, 0.2]; // ì˜µì €ë²„ê°€ ê°€ì¥ ë§ì´ ìŠ¤í°

                let random = Math.random();
                let MonsterClass = Observer;

                for (let i = 0; i < weights.length; i++) {
                    if (random < weights[i]) {
                        MonsterClass = monsterTypes[i];
                        break;
                    }
                    random -= weights[i];
                }

                gameState.monsters.push(new MonsterClass(x, y));
                gameState.lastMonsterSpawn = now;
            }
        }

        // ì¶©ëŒ ì²´í¬
        function checkCollisions() {
            // í”Œë ˆì´ì–´ì™€ ëª¬ìŠ¤í„° ì¶©ëŒ
            gameState.players.forEach(player => {
                if (!player.alive || player.invulnerable) return;

                gameState.monsters.forEach(monster => {
                    if (!monster.alive) return;

                    const distance = Math.sqrt(
                        Math.pow(player.x - monster.x, 2) +
                        Math.pow(player.y - monster.y, 2)
                    );

                    if (distance < player.size + monster.size - 5) {
                        player.alive = false;

                        if (player.id === gameState.myPlayerId) {
                            showGameOver();
                        }
                    }
                });
            });

            // í”Œë ˆì´ì–´ë¼ë¦¬ ì¶©ëŒ (ê¸°ì ˆ)
            const playerArray = Array.from(gameState.players.values());
            for (let i = 0; i < playerArray.length; i++) {
                for (let j = i + 1; j < playerArray.length; j++) {
                    const p1 = playerArray[i];
                    const p2 = playerArray[j];

                    if (!p1.alive || !p2.alive) continue;

                    const distance = Math.sqrt(
                        Math.pow(p1.x - p2.x, 2) +
                        Math.pow(p1.y - p2.y, 2)
                    );

                    if (distance < p1.size + p2.size) {
                        // ë‘˜ ë‹¤ ê¸°ì ˆ
                        p1.stunned = true;
                        p1.stunStart = Date.now();
                        p2.stunned = true;
                        p2.stunStart = Date.now();

                        // ì„œë¡œ ë°€ì–´ëƒ„
                        const pushForce = 20;
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 0) {
                            p1.x -= (dx / dist) * pushForce;
                            p1.y -= (dy / dist) * pushForce;
                            p2.x += (dx / dist) * pushForce;
                            p2.y += (dy / dist) * pushForce;
                        }
                    }
                }
            }

            // ì´ì•Œ ì¶©ëŒ
            gameState.bullets.forEach((bullet, bulletIndex) => {
                // í”Œë ˆì´ì–´ì™€ ì´ì•Œ ì¶©ëŒ
                gameState.players.forEach(player => {
                    if (player.id === bullet.shooterId || !player.alive) return;

                    const distance = Math.sqrt(
                        Math.pow(player.x - bullet.x, 2) +
                        Math.pow(player.y - bullet.y, 2)
                    );

                    if (distance < player.size + bullet.size) {
                        player.stunned = true;
                        player.stunStart = Date.now();
                        gameState.bullets.splice(bulletIndex, 1);
                    }
                });

                // ëª¬ìŠ¤í„°ì™€ ì´ì•Œ ì¶©ëŒ
                gameState.monsters.forEach((monster, monsterIndex) => {
                    if (!monster.alive) return;

                    const distance = Math.sqrt(
                        Math.pow(monster.x - bullet.x, 2) +
                        Math.pow(monster.y - bullet.y, 2)
                    );

                    if (distance < monster.size + bullet.size) {
                        monster.stunned = true;
                        monster.stunStart = Date.now();
                        gameState.bullets.splice(bulletIndex, 1);
                    }
                });
            });
        }

        // ê²Œì„ ì˜¤ë²„ í™”ë©´
        function showGameOver() {
            const myPlayer = gameState.players.get(gameState.myPlayerId);
            document.getElementById('finalScore').textContent =
                `ìµœì¢… ì ìˆ˜: ${myPlayer.score}ì  (ìƒì¡´ ì‹œê°„: ${Math.floor(myPlayer.score / 10)}ì´ˆ)`;
            document.getElementById('gameOver').style.display = 'block';
            gameState.gameRunning = false;
        }

        // ë¦¬ìŠ¤í°
        function respawn() {
            const myPlayer = gameState.players.get(gameState.myPlayerId);
            myPlayer.alive = true;
            myPlayer.invulnerable = true;
            myPlayer.invulnerabilityStart = Date.now();

            // ì•ˆì „í•œ ìœ„ì¹˜ ì°¾ê¸°
            let safeX, safeY;
            let attempts = 0;
            do {
                safeX = myPlayer.x + (Math.random() - 0.5) * 200;
                safeY = myPlayer.y + (Math.random() - 0.5) * 200;
                attempts++;
            } while (attempts < 20 && isTooCloseToMonsters(safeX, safeY));

            myPlayer.x = safeX;
            myPlayer.y = safeY;

            document.getElementById('gameOver').style.display = 'none';
            gameState.gameRunning = true;
            gameState.gameStartTime = Date.now();
        }

        // ëª¬ìŠ¤í„°ì™€ ë„ˆë¬´ ê°€ê¹Œìš´ì§€ í™•ì¸
        function isTooCloseToMonsters(x, y) {
            return gameState.monsters.some(monster => {
                const distance = Math.sqrt(
                    Math.pow(x - monster.x, 2) +
                    Math.pow(y - monster.y, 2)
                );
                return distance < 100;
            });
        }

        // í”Œë ˆì´ì–´ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updatePlayerList() {
            const playersDiv = document.getElementById('players');
            playersDiv.innerHTML = '';

            const sortedPlayers = Array.from(gameState.players.values())
                .sort((a, b) => b.score - a.score);

            sortedPlayers.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.style.color = player.color;
                playerDiv.style.margin = '2px 0';
                playerDiv.innerHTML = `
                    ${index + 1}. ${player.name}
                    ${player.alive ? 'ğŸŸ¢' : 'ğŸ’€'}
                    (${player.score}ì )
                `;
                playersDiv.appendChild(playerDiv);
            });
        }

        // UI ì—…ë°ì´íŠ¸
        function updateUI() {
            if (!gameState.gameRunning) return;

            const timeSurvived = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            document.getElementById('timeDisplay').textContent = timeSurvived;
            document.getElementById('observerCount').textContent = gameState.monsters.length;

            const myPlayer = gameState.players.get(gameState.myPlayerId);
            if (myPlayer) {
                document.getElementById('myScore').textContent = myPlayer.score;
            }
        }

        // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
        function updateCamera() {
            const myPlayer = gameState.players.get(gameState.myPlayerId);
            if (myPlayer && myPlayer.alive) {
                // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì¶”ì 
                const lerp = 0.1;
                gameState.camera.x += (myPlayer.x - gameState.camera.x) * lerp;
                gameState.camera.y += (myPlayer.y - gameState.camera.y) * lerp;
            }
        }

        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            if (!gameState.gameRunning) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // í™”ë©´ ì™„ì „íˆ í´ë¦¬ì–´ (ì”ìƒ íš¨ê³¼ ìµœì†Œí™”)
            ctx.fillStyle = '#000428';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ë°°ê²½ ë³„ë“¤ íš¨ê³¼ (ì¹´ë©”ë¼ ê¸°ì¤€)
            for (let i = 0; i < 100; i++) {
                const starX = (Math.sin(i * 12.9898) * 43758.5453) % gameState.mapSize.width;
                const starY = (Math.cos(i * 78.233) * 43758.5453) % gameState.mapSize.height;
                const screenX = starX - gameState.camera.x + canvas.width / 2;
                const screenY = starY - gameState.camera.y + canvas.height / 2;

                if (screenX >= 0 && screenX <= canvas.width &&
                    screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(i) * 0.2})`;
                    ctx.fillRect(screenX, screenY, 1, 1);
                }
            }

            // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
            updateCamera();

            // ëª¬ìŠ¤í„° ìŠ¤í°
            spawnMonster();

            // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸
            gameState.players.forEach(player => player.update());

            // ë´‡ ì—…ë°ì´íŠ¸
            updateBots();

            // ëª¬ìŠ¤í„° ì—…ë°ì´íŠ¸
            gameState.monsters.forEach(monster => monster.update());

            // ì´ì•Œ ì—…ë°ì´íŠ¸
            gameState.bullets = gameState.bullets.filter(bullet => bullet.update());

            // ì¶©ëŒ ì²´í¬
            checkCollisions();

            // ê·¸ë¦¬ê¸°
            gameState.monsters.forEach(monster => monster.draw());
            gameState.bullets.forEach(bullet => bullet.draw());
            gameState.players.forEach(player => player.draw());

            // UI ì—…ë°ì´íŠ¸
            updateUI();
            updatePlayerList();

            // ë„ˆë¬´ ë©€ë¦¬ ìˆëŠ” ëª¬ìŠ¤í„° ì œê±° (ìµœì í™”)
            const myPlayer = gameState.players.get(gameState.myPlayerId);
            if (myPlayer) {
                gameState.monsters = gameState.monsters.filter(monster => {
                    const distance = Math.sqrt(
                        Math.pow(monster.x - myPlayer.x, 2) +
                        Math.pow(monster.y - myPlayer.y, 2)
                    );
                    return distance < 800;
                });
            }

            requestAnimationFrame(gameLoop);
        }

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.code] = false;
        });

        // ì°½ í¬ê¸° ë³€ê²½ ì‹œ ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>