<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>멀티플레이어 몬스터 피하기</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, #0c1445, #1a237e);
        font-family: 'Courier New', monospace;
        color: #00ff00;
        overflow: hidden;
        height: 100vh;
      }

      .game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #gameCanvas {
        background: radial-gradient(circle at center, #000428, #004e92);
        border: 2px solid #00ff41;
        display: block;
        margin: 0 auto;
      }

      .ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #00ff41;
      }

      .player-list {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #00ff41;
        min-width: 200px;
      }

      .join-form {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border-radius: 10px;
        border: 2px solid #00ff41;
        text-align: center;
        z-index: 20;
      }

      input[type='text'] {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #00ff41;
        color: #00ff00;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
        font-family: inherit;
      }

      button {
        background: linear-gradient(45deg, #004e92, #000428);
        border: 2px solid #00ff41;
        color: #00ff00;
        padding: 10px 20px;
        cursor: pointer;
        border-radius: 5px;
        font-family: inherit;
        margin: 5px;
        transition: all 0.3s;
      }

      button:hover {
        background: linear-gradient(45deg, #006bb3, #001845);
        box-shadow: 0 0 10px #00ff41;
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        padding: 30px;
        border-radius: 10px;
        border: 2px solid #ff4444;
        text-align: center;
        z-index: 20;
        display: none;
      }

      .instructions {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #00ff41;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="join-form" id="joinForm">
        <h2>멀티플레이어 몬스터 피하기</h2>
        <p>닉네임을 입력하세요</p>
        <input type="text" id="playerName" placeholder="닉네임" maxlength="15" />
        <br />
        <button onclick="joinGame()">게임 참가</button>
        <div style="margin-top: 15px; font-size: 12px; color: #888">
          ✨ 서버 없이도 실시간 멀티플레이어!<br />
          🔗 링크를 공유해서 친구들과 함께 플레이하세요<br />
          🎮 현재 상태: <span id="connectionStatus">연결 대기 중...</span>
        </div>
      </div>

      <div class="ui" id="gameUI" style="display: none">
        <div>생존 시간: <span id="timeDisplay">0</span>초</div>
        <div>몬스터 수: <span id="observerCount">0</span></div>
        <div>내 점수: <span id="myScore">0</span></div>
      </div>

      <div class="player-list" id="playerList" style="display: none">
        <h3>플레이어 목록</h3>
        <div id="players"></div>
      </div>

      <canvas id="gameCanvas" style="display: none"></canvas>

      <div class="game-over" id="gameOver">
        <h2>게임 오버!</h2>
        <p id="finalScore"></p>
        <button onclick="respawn()">다시 시작</button>
      </div>

      <div class="instructions" id="instructions" style="display: none">
        화살표 키 또는 WASD로 이동 • 스페이스바로 총 발사 • 몬스터를 피하세요! • 다른 플레이어와 부딪히면 기절!
      </div>
    </div>

    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      // 캔버스 크기 설정
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // 게임 상태
      let gameState = {
        players: new Map(),
        monsters: [],
        bullets: [],
        myPlayerId: null,
        gameStartTime: Date.now(),
        lastMonsterSpawn: 0,
        keys: {},
        gameRunning: false,
        camera: { x: 0, y: 0 },
        mapSize: { width: 2000, height: 2000 },
        lastSpacePress: 0,
        roomId: null,
        isHost: false,
      };

      // 실시간 동기화를 위한 상태
      let syncState = {
        lastSync: 0,
        syncInterval: 100,
        peers: new Map(),
        isSyncing: false,
      };

      // 플레이어 클래스
      class Player {
        constructor(id, name, x, y, color) {
          this.id = id;
          this.name = name;
          this.x = x;
          this.y = y;
          this.color = color;
          this.alive = true;
          this.score = 0;
          this.size = 8;
          this.speed = 3;
          this.invulnerable = false;
          this.invulnerabilityStart = 0;
          this.stunned = false;
          this.stunStart = 0;
          this.bullets = 0;
          this.lastX = x;
          this.lastY = y;
        }

        update() {
          if (!this.alive) return;

          this.lastX = this.x;
          this.lastY = this.y;

          if (this.stunned && Date.now() - this.stunStart > 100) {
            this.stunned = false;
          }

          if (this.id === gameState.myPlayerId && !this.stunned) {
            let moved = false;
            if (gameState.keys['ArrowUp'] || gameState.keys['KeyW']) {
              this.y -= this.speed;
              moved = true;
            }
            if (gameState.keys['ArrowDown'] || gameState.keys['KeyS']) {
              this.y += this.speed;
              moved = true;
            }
            if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) {
              this.x -= this.speed;
              moved = true;
            }
            if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) {
              this.x += this.speed;
              moved = true;
            }

            if (gameState.keys['Space'] && this.bullets > 0 && Date.now() - gameState.lastSpacePress > 200) {
              this.shootBullet();
              gameState.lastSpacePress = Date.now();
            }

            if (moved) {
              const expandMargin = 200;
              if (this.x > gameState.mapSize.width - expandMargin) {
                gameState.mapSize.width = this.x + expandMargin;
              }
              if (this.y > gameState.mapSize.height - expandMargin) {
                gameState.mapSize.height = this.y + expandMargin;
              }
              if (this.x < expandMargin) {
                gameState.mapSize.width += expandMargin - this.x;
                const offset = expandMargin - this.x;
                gameState.players.forEach((p) => (p.x += offset));
                gameState.monsters.forEach((m) => (m.x += offset));
                gameState.bullets.forEach((b) => (b.x += offset));
                gameState.camera.x += offset;
              }
              if (this.y < expandMargin) {
                gameState.mapSize.height += expandMargin - this.y;
                const offset = expandMargin - this.y;
                gameState.players.forEach((p) => (p.y += offset));
                gameState.monsters.forEach((m) => (m.y += offset));
                gameState.bullets.forEach((b) => (b.y += offset));
                gameState.camera.y += offset;
              }
            }
          }

          if (this.invulnerable && Date.now() - this.invulnerabilityStart > 3000) {
            this.invulnerable = false;
          }

          this.score = Math.floor((Date.now() - gameState.gameStartTime) / 100);
          this.bullets = Math.floor(this.score / 1000);
        }

        shootBullet() {
          if (this.bullets <= 0) return;

          let closestTarget = null;
          let closestDistance = Infinity;

          gameState.players.forEach((player) => {
            if (player.id !== this.id && player.alive) {
              const distance = Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2));
              if (distance < closestDistance && distance < 200) {
                closestDistance = distance;
                closestTarget = player;
              }
            }
          });

          gameState.monsters.forEach((monster) => {
            const distance = Math.sqrt(Math.pow(monster.x - this.x, 2) + Math.pow(monster.y - this.y, 2));
            if (distance < closestDistance && distance < 200) {
              closestDistance = distance;
              closestTarget = monster;
            }
          });

          if (closestTarget) {
            const angle = Math.atan2(closestTarget.y - this.y, closestTarget.x - this.x);
            const bullet = new Bullet(this.x, this.y, angle, this.id);
            bullet.id = 'bullet_' + Date.now() + '_' + Math.random();
            gameState.bullets.push(bullet);
            this.bullets--;
          }
        }

        draw() {
          const screenX = this.x - gameState.camera.x + canvas.width / 2;
          const screenY = this.y - gameState.camera.y + canvas.height / 2;

          if (this.invulnerable) {
            const blinkSpeed = 200;
            const isVisible = Math.floor(Date.now() / blinkSpeed) % 2 === 0;
            if (!isVisible) return;
          }

          if (this.stunned) {
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(Math.sin(Date.now() * 0.05) * 0.2);
            ctx.translate(-screenX, -screenY);
          }

          ctx.fillStyle = this.alive ? this.color : '#666666';
          ctx.beginPath();
          ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = this.alive ? '#ffffff' : '#333333';
          ctx.lineWidth = 2;
          ctx.stroke();

          if (this.stunned) {
            ctx.fillStyle = '#ffff00';
            ctx.font = '20px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('⭐', screenX, screenY + 5);
            ctx.restore();
          }

          if (this.invulnerable) {
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(screenX, screenY, this.size + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
          }

          ctx.fillStyle = '#ffffff';
          ctx.font = '12px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(this.name, screenX, screenY - 15);

          if (this.bullets > 0) {
            ctx.fillStyle = '#00ff00';
            ctx.font = '10px Courier New';
            ctx.fillText('🔫' + this.bullets, screenX, screenY + 20);
          }

          if (!this.alive) {
            ctx.fillStyle = '#ff4444';
            ctx.font = '16px Courier New';
            ctx.fillText('💀', screenX, screenY + 5);
          }
        }
      }

      // 몬스터 베이스 클래스
      class Monster {
        constructor(x, y, type) {
          this.x = x;
          this.y = y;
          this.type = type;
          this.alive = true;
          this.stunned = false;
          this.stunStart = 0;
          this.angle = 0;
        }

        update() {
          if (!this.alive) return;

          if (this.stunned && Date.now() - this.stunStart > 2000) {
            this.stunned = false;
          }

          if (!this.stunned) {
            this.ai();
          }

          this.angle += 0.1;
        }

        ai() {
          // 오버라이드됨
        }

        draw() {
          const screenX = this.x - gameState.camera.x + canvas.width / 2;
          const screenY = this.y - gameState.camera.y + canvas.height / 2;

          if (screenX < -50 || screenX > canvas.width + 50 || screenY < -50 || screenY > canvas.height + 50) {
            return;
          }

          if (this.stunned) {
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(Math.sin(Date.now() * 0.02) * 0.3);
            ctx.translate(-screenX, -screenY);
            ctx.fillStyle = '#666666';
          } else {
            ctx.fillStyle = this.color;
          }

          this.drawShape(screenX, screenY);

          if (this.stunned) {
            ctx.fillStyle = '#ffff00';
            ctx.font = '16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('💫', screenX, screenY - 20);
            ctx.restore();
          }
        }
      }

      // 옵저버
      class Observer extends Monster {
        constructor(x, y) {
          super(x, y, 'observer');
          this.size = 15;
          this.speed = 1.5;
          this.color = '#ff6600';
        }

        ai() {
          let closestPlayer = null;
          let closestDistance = Infinity;

          gameState.players.forEach((player) => {
            if (player.alive && !player.invulnerable) {
              const distance = Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2));
              if (distance < closestDistance) {
                closestDistance = distance;
                closestPlayer = player;
              }
            }
          });

          if (closestPlayer) {
            const dx = closestPlayer.x - this.x;
            const dy = closestPlayer.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
              this.x += (dx / distance) * this.speed;
              this.y += (dy / distance) * this.speed;
            }
          }
        }

        drawShape(screenX, screenY) {
          ctx.save();
          ctx.translate(screenX, screenY);
          ctx.rotate(this.angle);

          ctx.beginPath();
          ctx.ellipse(0, 0, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#ffaa44';
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.fillStyle = '#00ffff';
          ctx.beginPath();
          ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 1;
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle) * this.size, Math.sin(angle) * this.size);
            ctx.stroke();
          }

          ctx.restore();
        }
      }

      // 러셔
      class Rusher extends Monster {
        constructor(x, y) {
          super(x, y, 'rusher');
          this.size = 10;
          this.speed = 4;
          this.color = '#ff3333';
          this.rushTarget = null;
          this.rushCooldown = 0;
        }

        ai() {
          const now = Date.now();

          if (now - this.rushCooldown > 3000) {
            let closestPlayer = null;
            let closestDistance = Infinity;

            gameState.players.forEach((player) => {
              if (player.alive) {
                const distance = Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2));
                if (distance < closestDistance && distance < 300) {
                  closestDistance = distance;
                  closestPlayer = player;
                }
              }
            });

            if (closestPlayer) {
              this.rushTarget = { x: closestPlayer.x, y: closestPlayer.y };
              this.rushCooldown = now;
            }
          }

          if (this.rushTarget) {
            const dx = this.rushTarget.x - this.x;
            const dy = this.rushTarget.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 5) {
              this.x += (dx / distance) * this.speed;
              this.y += (dy / distance) * this.speed;
            } else {
              this.rushTarget = null;
            }
          }
        }

        drawShape(screenX, screenY) {
          ctx.beginPath();
          ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2 + this.angle;
            const startX = screenX + Math.cos(angle) * this.size;
            const startY = screenY + Math.sin(angle) * this.size;
            const endX = screenX + Math.cos(angle) * (this.size + 5);
            const endY = screenY + Math.sin(angle) * (this.size + 5);

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          }
        }
      }

      // 패트롤러
      class Patroller extends Monster {
        constructor(x, y) {
          super(x, y, 'patroller');
          this.size = 12;
          this.speed = 2;
          this.color = '#9933ff';
          this.patrolTarget = { x: x + Math.random() * 200 - 100, y: y + Math.random() * 200 - 100 };
          this.patrolRadius = 150;
          this.centerX = x;
          this.centerY = y;
        }

        ai() {
          const dx = this.patrolTarget.x - this.x;
          const dy = this.patrolTarget.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 20) {
            const angle = Math.random() * Math.PI * 2;
            this.patrolTarget = {
              x: this.centerX + Math.cos(angle) * this.patrolRadius,
              y: this.centerY + Math.sin(angle) * this.patrolRadius,
            };
          } else {
            this.x += (dx / distance) * this.speed;
            this.y += (dy / distance) * this.speed;
          }
        }

        drawShape(screenX, screenY) {
          ctx.save();
          ctx.translate(screenX, screenY);
          ctx.rotate(this.angle);

          ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.strokeRect(-this.size / 2, -this.size / 2, this.size, this.size);

          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(0, 0, 3, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }

      // 총알 클래스
      class Bullet {
        constructor(x, y, angle, shooterId) {
          this.x = x;
          this.y = y;
          this.angle = angle;
          this.speed = 8;
          this.shooterId = shooterId;
          this.size = 3;
          this.life = 1000;
          this.createTime = Date.now();
        }

        update() {
          this.x += Math.cos(this.angle) * this.speed;
          this.y += Math.sin(this.angle) * this.speed;

          if (Date.now() - this.createTime > this.life) {
            return false;
          }

          return true;
        }

        draw() {
          const screenX = this.x - gameState.camera.x + canvas.width / 2;
          const screenY = this.y - gameState.camera.y + canvas.height / 2;

          ctx.fillStyle = '#ffff00';
          ctx.beginPath();
          ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(screenX, screenY);
          ctx.lineTo(screenX - Math.cos(this.angle) * 10, screenY - Math.sin(this.angle) * 10);
          ctx.stroke();
        }
      }

      // 게임 참가
      function joinGame() {
        const nameInput = document.getElementById('playerName');
        const name = nameInput.value.trim();

        if (!name) {
          alert('닉네임을 입력하세요!');
          return;
        }

        const urlParams = new URLSearchParams(window.location.search);
        let roomId = urlParams.get('room');

        if (!roomId) {
          roomId = 'room_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          gameState.isHost = true;

          // URL 업데이트 (오류 방지)
          try {
            const newUrl =
              window.location.protocol + '//' + window.location.host + window.location.pathname + '?room=' + roomId;
            window.history.pushState({ path: newUrl }, '', newUrl);
            showRoomLink(newUrl);
          } catch (error) {
            // Claude 환경에서는 URL 조작 불가, GitHub.io에서는 정상 작동
            const simulatedUrl = 'https://yourusername.github.io/your-game?room=' + roomId;
            showRoomLink(simulatedUrl);
            console.log('실제 배포 시 사용할 방 ID:', roomId);
          }
        }

        gameState.roomId = roomId;

        // 연결 상태 업데이트
        const statusElement = document.getElementById('connectionStatus');
        if (statusElement) {
          statusElement.textContent = gameState.isHost ? '방장 (호스트)' : '참가자';
          statusElement.style.color = gameState.isHost ? '#ffaa00' : '#00ff00';
        }

        document.getElementById('joinForm').style.display = 'none';
        document.getElementById('gameCanvas').style.display = 'block';
        document.getElementById('gameUI').style.display = 'block';
        document.getElementById('playerList').style.display = 'block';
        document.getElementById('instructions').style.display = 'block';

        const playerId = 'player_' + Date.now() + '_' + Math.random();
        const playerColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
        const startX = 400;
        const startY = 400;

        const player = new Player(playerId, name, startX, startY, playerColor);
        gameState.players.set(playerId, player);
        gameState.myPlayerId = playerId;
        gameState.gameRunning = true;
        gameState.gameStartTime = Date.now();

        initLocalStorageSync();
        gameLoop();
      }

      // 방 링크 표시
      function showRoomLink(url) {
        const linkDiv = document.createElement('div');
        linkDiv.style.position = 'fixed';
        linkDiv.style.top = '10px';
        linkDiv.style.left = '50%';
        linkDiv.style.transform = 'translateX(-50%)';
        linkDiv.style.background = 'rgba(0, 0, 0, 0.9)';
        linkDiv.style.color = '#00ff00';
        linkDiv.style.padding = '10px';
        linkDiv.style.borderRadius = '5px';
        linkDiv.style.border = '1px solid #00ff41';
        linkDiv.style.zIndex = '100';
        linkDiv.style.textAlign = 'center';
        linkDiv.innerHTML = `
                <div>친구들과 함께 플레이하려면 이 링크를 공유하세요:</div>
                <input type="text" value="${url}" readonly style="width: 400px; margin: 5px; padding: 5px; background: #000; color: #00ff00; border: 1px solid #00ff41;" id="roomLinkInput">
                <button onclick="copyToClipboard('${url}')" style="margin: 5px; padding: 5px 10px; background: #004e92; color: #00ff00; border: 1px solid #00ff41; cursor: pointer;">복사</button>
                <button onclick="this.parentElement.remove()" style="margin: 5px; padding: 5px 10px; background: #004e92; color: #00ff00; border: 1px solid #00ff41; cursor: pointer;">닫기</button>
                <div style="font-size: 10px; margin-top: 10px; color: #888;">
                    💡 현재 Claude 환경에서는 URL 링크가 제한됩니다.<br>
                    GitHub.io에 배포하면 실제 링크로 친구 초대가 가능합니다!<br>
                    지금은 같은 브라우저에서 새 탭을 열어서 테스트해보세요.
                </div>
            `;
        document.body.appendChild(linkDiv);
      }

      // 클립보드 복사
      function copyToClipboard(text) {
        try {
          navigator.clipboard
            .writeText(text)
            .then(() => {
              alert('링크가 복사되었습니다!');
            })
            .catch(() => {
              // 폴백: 텍스트 선택
              const textArea = document.createElement('textarea');
              textArea.value = text;
              document.body.appendChild(textArea);
              textArea.select();
              document.execCommand('copy');
              document.body.removeChild(textArea);
              alert('링크가 복사되었습니다!');
            });
        } catch (error) {
          alert('링크를 수동으로 복사해주세요: ' + text);
        }
      }

      // localStorage 동기화 시스템
      function initLocalStorageSync() {
        // 더 안정적인 동기화 간격
        setInterval(syncWithLocalStorage, 200);

        // storage 이벤트는 제거 (무한루프 방지)
        // window.addEventListener('storage', handleStorageChange);
      }

      // localStorage와 동기화
      function syncWithLocalStorage() {
        if (!gameState.roomId || syncState.isSyncing) return;

        syncState.isSyncing = true;

        try {
          const roomKey = 'gameRoom_' + gameState.roomId;
          const roomDataStr = localStorage.getItem(roomKey);
          let roomData;

          if (!roomDataStr) {
            // 방 데이터가 없으면 새로 생성
            roomData = {
              players: {},
              monsters: [],
              bullets: [],
              gameStartTime: gameState.gameStartTime,
              lastUpdate: Date.now(),
            };
          } else {
            roomData = JSON.parse(roomDataStr);
          }

          // 내 플레이어 정보 업데이트
          const myPlayer = gameState.players.get(gameState.myPlayerId);
          if (myPlayer) {
            roomData.players[gameState.myPlayerId] = {
              id: myPlayer.id,
              name: myPlayer.name,
              x: myPlayer.x,
              y: myPlayer.y,
              color: myPlayer.color,
              alive: myPlayer.alive,
              score: myPlayer.score,
              bullets: myPlayer.bullets,
              invulnerable: myPlayer.invulnerable,
              stunned: myPlayer.stunned,
              lastUpdate: Date.now(),
            };
          }

          // 다른 플레이어들 정보 가져오기 (덮어쓰지 않고 업데이트만)
          Object.values(roomData.players).forEach((playerData) => {
            if (playerData.id !== gameState.myPlayerId) {
              if (!gameState.players.has(playerData.id)) {
                // 새 플레이어 추가
                const newPlayer = new Player(
                  playerData.id,
                  playerData.name,
                  playerData.x,
                  playerData.y,
                  playerData.color
                );
                newPlayer.alive = playerData.alive;
                newPlayer.score = playerData.score;
                newPlayer.bullets = playerData.bullets;
                newPlayer.invulnerable = playerData.invulnerable;
                newPlayer.stunned = playerData.stunned;
                gameState.players.set(playerData.id, newPlayer);
              } else {
                // 기존 플레이어 업데이트 (최근 업데이트만)
                const existingPlayer = gameState.players.get(playerData.id);
                const timeDiff = Date.now() - (playerData.lastUpdate || 0);

                if (timeDiff < 3000) {
                  // 3초 이내 데이터만 신뢰
                  existingPlayer.x = playerData.x;
                  existingPlayer.y = playerData.y;
                  existingPlayer.alive = playerData.alive;
                  existingPlayer.score = playerData.score;
                  existingPlayer.bullets = playerData.bullets;
                  existingPlayer.invulnerable = playerData.invulnerable;
                  existingPlayer.stunned = playerData.stunned;
                }
              }
            }
          });

          // 호스트만 몬스터와 총알 관리
          if (gameState.isHost) {
            roomData.monsters = gameState.monsters.map((m) => ({
              id: m.id,
              type: m.type,
              x: m.x,
              y: m.y,
              alive: m.alive,
              stunned: m.stunned,
              stunStart: m.stunStart,
              angle: m.angle,
            }));

            roomData.bullets = gameState.bullets.map((b) => ({
              id: b.id,
              x: b.x,
              y: b.y,
              angle: b.angle,
              shooterId: b.shooterId,
              createTime: b.createTime,
            }));

            roomData.gameStartTime = gameState.gameStartTime;
          }

          // 클라이언트는 호스트의 몬스터/총알 정보만 받기
          if (!gameState.isHost && roomData.monsters && roomData.bullets) {
            // 몬스터 동기화
            const newMonsters = [];
            roomData.monsters.forEach((monsterData) => {
              let monster;
              switch (monsterData.type) {
                case 'observer':
                  monster = new Observer(monsterData.x, monsterData.y);
                  break;
                case 'rusher':
                  monster = new Rusher(monsterData.x, monsterData.y);
                  break;
                case 'patroller':
                  monster = new Patroller(monsterData.x, monsterData.y);
                  break;
                default:
                  monster = new Observer(monsterData.x, monsterData.y);
              }
              monster.id = monsterData.id;
              monster.x = monsterData.x;
              monster.y = monsterData.y;
              monster.alive = monsterData.alive;
              monster.stunned = monsterData.stunned;
              monster.stunStart = monsterData.stunStart;
              monster.angle = monsterData.angle;
              newMonsters.push(monster);
            });
            gameState.monsters = newMonsters;

            // 총알 동기화
            const newBullets = [];
            roomData.bullets.forEach((bulletData) => {
              const bullet = new Bullet(bulletData.x, bulletData.y, bulletData.angle, bulletData.shooterId);
              bullet.id = bulletData.id;
              bullet.createTime = bulletData.createTime;
              newBullets.push(bullet);
            });
            gameState.bullets = newBullets;

            // 게임 시작 시간 동기화
            if (roomData.gameStartTime) {
              gameState.gameStartTime = roomData.gameStartTime;
            }
          }

          localStorage.setItem(roomKey, JSON.stringify(roomData));
        } catch (error) {
          console.error('동기화 오류:', error);
        } finally {
          syncState.isSyncing = false;
        }
      }

      // 스토리지 변경 감지 (제거됨 - 무한루프 방지)

      // 몬스터 스폰
      function spawnMonster() {
        const now = Date.now();
        const timeSinceStart = (now - gameState.gameStartTime) / 1000;
        const spawnInterval = Math.max(1000 - timeSinceStart * 30, 200);

        if (now - gameState.lastMonsterSpawn > spawnInterval) {
          const myPlayer = gameState.players.get(gameState.myPlayerId);
          if (!myPlayer) return;

          const spawnCount = Math.min(Math.floor(timeSinceStart / 10) + 1, 5);

          for (let i = 0; i < spawnCount; i++) {
            const spawnDistance = 300 + Math.random() * 200;
            const angle = Math.random() * Math.PI * 2;
            const x = myPlayer.x + Math.cos(angle) * spawnDistance;
            const y = myPlayer.y + Math.sin(angle) * spawnDistance;

            const monsterTypes = [Observer, Rusher, Patroller];
            const weights = [0.4, 0.4, 0.2];

            let random = Math.random();
            let MonsterClass = Observer;

            for (let j = 0; j < weights.length; j++) {
              if (random < weights[j]) {
                MonsterClass = monsterTypes[j];
                break;
              }
              random -= weights[j];
            }

            const monster = new MonsterClass(x, y);
            monster.id = 'monster_' + Date.now() + '_' + Math.random();
            gameState.monsters.push(monster);
          }

          gameState.lastMonsterSpawn = now;
        }
      }

      // 충돌 체크
      function checkCollisions() {
        gameState.players.forEach((player) => {
          if (!player.alive || player.invulnerable) return;

          gameState.monsters.forEach((monster) => {
            if (!monster.alive) return;

            const distance = Math.sqrt(Math.pow(player.x - monster.x, 2) + Math.pow(player.y - monster.y, 2));

            if (distance < player.size + monster.size - 5) {
              player.alive = false;

              if (player.id === gameState.myPlayerId) {
                showGameOver();
              }
            }
          });
        });

        const playerArray = Array.from(gameState.players.values());
        for (let i = 0; i < playerArray.length; i++) {
          for (let j = i + 1; j < playerArray.length; j++) {
            const p1 = playerArray[i];
            const p2 = playerArray[j];

            if (!p1.alive || !p2.alive) continue;

            const distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

            if (distance < p1.size + p2.size) {
              p1.stunned = true;
              p1.stunStart = Date.now();
              p2.stunned = true;
              p2.stunStart = Date.now();

              const pushForce = 20;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (dist > 0) {
                p1.x -= (dx / dist) * pushForce;
                p1.y -= (dy / dist) * pushForce;
                p2.x += (dx / dist) * pushForce;
                p2.y += (dy / dist) * pushForce;
              }
            }
          }
        }

        gameState.bullets.forEach((bullet, bulletIndex) => {
          gameState.players.forEach((player) => {
            if (player.id === bullet.shooterId || !player.alive) return;

            const distance = Math.sqrt(Math.pow(player.x - bullet.x, 2) + Math.pow(player.y - bullet.y, 2));

            if (distance < player.size + bullet.size) {
              player.stunned = true;
              player.stunStart = Date.now();
              gameState.bullets.splice(bulletIndex, 1);
            }
          });

          gameState.monsters.forEach((monster, monsterIndex) => {
            if (!monster.alive) return;

            const distance = Math.sqrt(Math.pow(monster.x - bullet.x, 2) + Math.pow(monster.y - bullet.y, 2));

            if (distance < monster.size + bullet.size) {
              monster.stunned = true;
              monster.stunStart = Date.now();
              gameState.bullets.splice(bulletIndex, 1);
            }
          });
        });
      }

      // 게임 오버 화면
      function showGameOver() {
        const myPlayer = gameState.players.get(gameState.myPlayerId);
        document.getElementById('finalScore').textContent = `최종 점수: ${myPlayer.score}점 (생존 시간: ${Math.floor(
          myPlayer.score / 10
        )}초)`;
        document.getElementById('gameOver').style.display = 'block';
        gameState.gameRunning = false;
      }

      // 리스폰
      function respawn() {
        const myPlayer = gameState.players.get(gameState.myPlayerId);
        myPlayer.alive = true;
        myPlayer.invulnerable = true;
        myPlayer.invulnerabilityStart = Date.now();

        let safeX, safeY;
        let attempts = 0;
        do {
          safeX = myPlayer.x + (Math.random() - 0.5) * 200;
          safeY = myPlayer.y + (Math.random() - 0.5) * 200;
          attempts++;
        } while (attempts < 20 && isTooCloseToMonsters(safeX, safeY));

        myPlayer.x = safeX;
        myPlayer.y = safeY;

        document.getElementById('gameOver').style.display = 'none';
        gameState.gameRunning = true;
        gameState.gameStartTime = Date.now();
      }

      // 몬스터와 너무 가까운지 확인
      function isTooCloseToMonsters(x, y) {
        return gameState.monsters.some((monster) => {
          const distance = Math.sqrt(Math.pow(x - monster.x, 2) + Math.pow(y - monster.y, 2));
          return distance < 100;
        });
      }

      // 플레이어 목록 업데이트
      function updatePlayerList() {
        const playersDiv = document.getElementById('players');
        playersDiv.innerHTML = '';

        const sortedPlayers = Array.from(gameState.players.values()).sort((a, b) => b.score - a.score);

        sortedPlayers.forEach((player, index) => {
          const playerDiv = document.createElement('div');
          playerDiv.style.color = player.color;
          playerDiv.style.margin = '2px 0';
          playerDiv.innerHTML = `
                    ${index + 1}. ${player.name}
                    ${player.alive ? '🟢' : '💀'}
                    (${player.score}점)
                `;
          playersDiv.appendChild(playerDiv);
        });
      }

      // UI 업데이트
      function updateUI() {
        if (!gameState.gameRunning) return;

        const timeSurvived = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
        document.getElementById('timeDisplay').textContent = timeSurvived;
        document.getElementById('observerCount').textContent = gameState.monsters.length;

        const myPlayer = gameState.players.get(gameState.myPlayerId);
        if (myPlayer) {
          document.getElementById('myScore').textContent = myPlayer.score;
        }
      }

      // 카메라 업데이트
      function updateCamera() {
        const myPlayer = gameState.players.get(gameState.myPlayerId);
        if (myPlayer && myPlayer.alive) {
          const lerp = 0.1;
          gameState.camera.x += (myPlayer.x - gameState.camera.x) * lerp;
          gameState.camera.y += (myPlayer.y - gameState.camera.y) * lerp;
        }
      }

      // 게임 루프
      function gameLoop() {
        if (!gameState.gameRunning) {
          requestAnimationFrame(gameLoop);
          return;
        }

        // 화면 클리어
        ctx.fillStyle = '#000428';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 배경 별들
        for (let i = 0; i < 100; i++) {
          const starX = (Math.sin(i * 12.9898) * 43758.5453) % gameState.mapSize.width;
          const starY = (Math.cos(i * 78.233) * 43758.5453) % gameState.mapSize.height;
          const screenX = starX - gameState.camera.x + canvas.width / 2;
          const screenY = starY - gameState.camera.y + canvas.height / 2;

          if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(i) * 0.2})`;
            ctx.fillRect(screenX, screenY, 1, 1);
          }
        }

        // 카메라 업데이트
        updateCamera();

        // 호스트만 몬스터 스폰 및 AI 관리
        if (gameState.isHost) {
          spawnMonster();
          gameState.monsters.forEach((monster) => monster.update());
          gameState.bullets = gameState.bullets.filter((bullet) => bullet.update());

          // 몬스터 정리
          const anyPlayer = Array.from(gameState.players.values()).find((p) => p.alive);
          if (anyPlayer) {
            gameState.monsters = gameState.monsters.filter((monster) => {
              const distance = Math.sqrt(Math.pow(monster.x - anyPlayer.x, 2) + Math.pow(monster.y - anyPlayer.y, 2));
              return distance < 1000;
            });
          }
        }

        // 모든 플레이어 업데이트 (각자 자신만)
        const myPlayer = gameState.players.get(gameState.myPlayerId);
        if (myPlayer) {
          myPlayer.update();
        }

        // 충돌 체크
        checkCollisions();

        // 그리기
        gameState.monsters.forEach((monster) => monster.draw());
        gameState.bullets.forEach((bullet) => bullet.draw());
        gameState.players.forEach((player) => player.draw());

        // UI 업데이트
        updateUI();
        updatePlayerList();

        requestAnimationFrame(gameLoop);
      }

      // 키보드 이벤트
      document.addEventListener('keydown', (e) => {
        gameState.keys[e.code] = true;
      });

      document.addEventListener('keyup', (e) => {
        gameState.keys[e.code] = false;
      });

      // 창 크기 변경 시 캔버스 크기 조정
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });

      // 페이지 종료시 정리
      window.addEventListener('beforeunload', () => {
        if (gameState.roomId && gameState.myPlayerId) {
          const roomKey = 'gameRoom_' + gameState.roomId;
          const roomDataStr = localStorage.getItem(roomKey);
          if (roomDataStr) {
            try {
              const roomData = JSON.parse(roomDataStr);
              delete roomData.players[gameState.myPlayerId];
              localStorage.setItem(roomKey, JSON.stringify(roomData));
            } catch (error) {
              console.error('정리 중 오류:', error);
            }
          }
        }
      });
    </script>
  </body>
</html>
