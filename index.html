<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë©€í‹°í”Œë ˆì´ì–´ ëª¬ìŠ¤í„° í”¼í•˜ê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0c1445, #1a237e);
            font-family: 'Courier New', monospace;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            background: radial-gradient(circle at center, #000428, #004e92);
            border: 2px solid #00ff41;
            display: block;
            margin: 0 auto;
        }

        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ff41;
        }

        .player-list {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ff41;
            min-width: 200px;
        }

        .join-form {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #00ff41;
            text-align: center;
            z-index: 20;
        }

        input[type="text"] {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff41;
            color: #00ff00;
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            font-family: inherit;
        }

        button {
            background: linear-gradient(45deg, #004e92, #000428);
            border: 2px solid #00ff41;
            color: #00ff00;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            font-family: inherit;
            margin: 5px;
            transition: all 0.3s;
        }

        button:hover {
            background: linear-gradient(45deg, #006bb3, #001845);
            box-shadow: 0 0 10px #00ff41;
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(30, 30, 30, 0.7); /* íšŒìƒ‰ ë°˜íˆ¬ëª… ë°°ê²½ */
            display: none; /* ê¸°ë³¸ì ìœ¼ë¡œ ìˆ¨ê¹€ */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 15;
            text-align: center;
            color: #ff4444;
        }

        .game-over h2 {
            font-size: 48px;
            text-shadow: 0 0 10px #ff0000;
        }

        .game-over p {
            font-size: 24px;
            margin-bottom: 100px; /* ë²„íŠ¼ê³¼ì˜ ê°„ê²© */
        }

        .respawn-button {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-size: 18px;
            background: linear-gradient(45deg, #ff4444, #b30000);
            border: 2px solid #ff8888;
            color: #ffffff;
        }

        .instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ff41;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="join-form" id="joinForm">
            <h2>ë©€í‹°í”Œë ˆì´ì–´ ëª¬ìŠ¤í„° í”¼í•˜ê¸°</h2>
            <p>ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”</p>
            <input type="text" id="playerName" placeholder="ë‹‰ë„¤ì„" maxlength="15">
            <br>
            <button onclick="joinGame()">ê²Œì„ ì°¸ê°€</button>
            <div style="margin-top: 15px; font-size: 12px; color: #888;">
                âœ¨ ì„œë²„ ì—†ì´ë„ ì‹¤ì‹œê°„ ë©€í‹°í”Œë ˆì´ì–´!<br>
                ğŸ”— ë§í¬ë¥¼ ê³µìœ í•´ì„œ ì¹œêµ¬ë“¤ê³¼ í•¨ê»˜ í”Œë ˆì´í•˜ì„¸ìš”<br>
                ğŸ® í˜„ì¬ ìƒíƒœ: <span id="connectionStatus">ì—°ê²° ëŒ€ê¸° ì¤‘...</span>
            </div>
        </div>

        <div class="ui" id="gameUI" style="display: none;">
            <div>ìƒì¡´ ì‹œê°„: <span id="timeDisplay">0</span>ì´ˆ</div>
            <div>ëª¬ìŠ¤í„° ìˆ˜: <span id="observerCount">0</span></div>
            <div>ë‚´ ì ìˆ˜: <span id="myScore">0</span></div>
        </div>

        <div class="player-list" id="playerList" style="display: none;">
            <h3>í”Œë ˆì´ì–´ ëª©ë¡</h3>
            <div id="players"></div>
        </div>

        <canvas id="gameCanvas" style="display: none;"></canvas>

        <div class="game-over" id="gameOver">
            <h2>GAME OVER</h2>
            <p id="finalScore"></p>
            <button class="respawn-button" onclick="respawn()">ë‹¤ì‹œ ì‹œì‘</button>
        </div>

        <div class="instructions" id="instructions" style="display: none;">
            í™”ì‚´í‘œ í‚¤ ë˜ëŠ” WASDë¡œ ì´ë™ â€¢ ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ì´ ë°œì‚¬ â€¢ ëª¬ìŠ¤í„°ë¥¼ í”¼í•˜ì„¸ìš”! â€¢ ë‹¤ë¥¸ í”Œë ˆì´ì–´ì™€ ë¶€ë”ªíˆë©´ ê¸°ì ˆ!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let gameState = {
            players: new Map(),
            monsters: [],
            bullets: [],
            myPlayerId: null,
            gameStartTime: Date.now(),
            lastMonsterSpawn: 0,
            keys: {},
            gameRunning: false,
            camera: { x: 0, y: 0 },
            mapSize: { width: 2000, height: 2000 },
            lastSpacePress: 0,
            roomId: null,
            isHost: false,
            hostId: null
        };

        let gameChannel = null;
        let lastBroadcast = 0;

        class Player {
            constructor(id, name, x, y, color) {
                this.id = id;
                this.name = name;
                this.x = x;
                this.y = y;
                this.color = color;
                this.alive = true;
                this.score = 0;
                this.size = 8;
                this.speed = 3;
                this.invulnerable = false;
                this.invulnerabilityStart = 0;
                this.stunned = false;
                this.stunStart = 0;
                this.bullets = 0;
            }

            update() {
                if (!this.alive) return;

                if (this.stunned && Date.now() - this.stunStart > 100) {
                    this.stunned = false;
                }

                if (this.id === gameState.myPlayerId && !this.stunned) {
                    let moved = false;
                    if (gameState.keys['ArrowUp'] || gameState.keys['KeyW']) {
                        this.y -= this.speed;
                        moved = true;
                    }
                    if (gameState.keys['ArrowDown'] || gameState.keys['KeyS']) {
                        this.y += this.speed;
                        moved = true;
                    }
                    if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) {
                        this.x -= this.speed;
                        moved = true;
                    }
                    if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) {
                        this.x += this.speed;
                        moved = true;
                    }

                    if (gameState.keys['Space'] &&
                        Date.now() - gameState.lastSpacePress > 200) {
                        this.shootBullet();
                        gameState.lastSpacePress = Date.now();
                    }

                    if (moved) {
                        const expandMargin = 200;
                        if (this.x > gameState.mapSize.width - expandMargin) {
                            gameState.mapSize.width = this.x + expandMargin;
                        }
                        if (this.y > gameState.mapSize.height - expandMargin) {
                            gameState.mapSize.height = this.y + expandMargin;
                        }
                        if (this.x < expandMargin) {
                            gameState.mapSize.width += expandMargin - this.x;
                            const offset = expandMargin - this.x;
                            gameState.players.forEach(p => p.x += offset);
                            gameState.monsters.forEach(m => m.x += offset);
                            gameState.bullets.forEach(b => b.x += offset);
                            gameState.camera.x += offset;
                        }
                        if (this.y < expandMargin) {
                            gameState.mapSize.height += expandMargin - this.y;
                            const offset = expandMargin - this.y;
                            gameState.players.forEach(p => p.y += offset);
                            gameState.monsters.forEach(m => m.y += offset);
                            gameState.bullets.forEach(b => b.y += offset);
                            gameState.camera.y += offset;
                        }
                    }
                }

                if (this.invulnerable && Date.now() - this.invulnerabilityStart > 3000) {
                    this.invulnerable = false;
                }

                this.score = Math.floor((Date.now() - gameState.gameStartTime) / 100);
                // ì´ì•Œ ê°œìˆ˜ í‘œì‹œëŠ” ë ˆë²¨ë¡œ ë³€ê²½
                this.bulletLevel = Math.floor(this.score / 1000);
            }

            shootBullet() {
                // ì´ì•Œ ë¬´ì œí•œ ë°œì‚¬
                let closestTarget = null;
                let closestDistance = Infinity;

                gameState.players.forEach(player => {
                    if (player.id !== this.id && player.alive) {
                        const distance = Math.sqrt(
                            Math.pow(player.x - this.x, 2) +
                            Math.pow(player.y - this.y, 2)
                        );
                        if (distance < closestDistance && distance < 200) {
                            closestDistance = distance;
                            closestTarget = player;
                        }
                    }
                });

                gameState.monsters.forEach(monster => {
                    const distance = Math.sqrt(
                        Math.pow(monster.x - this.x, 2) +
                        Math.pow(monster.y - this.y, 2)
                    );
                    if (distance < closestDistance && distance < 200) {
                        closestDistance = distance;
                        closestTarget = monster;
                    }
                });

                if (closestTarget) {
                    const angle = Math.atan2(closestTarget.y - this.y, closestTarget.x - this.x);

                    // ì ìˆ˜ì— ë”°ë¥¸ ì´ì•Œ í¬ê¸° ê³„ì‚° (1000ì  = 1ë°°, 10000ì  = 2ë°°)
                    const bulletLevel = Math.floor(this.score / 1000);
                    const bulletSize = 3 + (bulletLevel * 0.1); // ê¸°ë³¸ 3 + ë ˆë²¨ë‹¹ 0.1ì”© ì¦ê°€
                    const bulletRange = 20 + (bulletLevel * 2); // ì¶©ëŒ ë²”ìœ„ë„ ì¦ê°€

                    const bullet = new Bullet(this.x, this.y, angle, this.id, bulletSize, bulletRange);
                    bullet.id = 'bullet_' + Date.now() + '_' + Math.random();
                    gameState.bullets.push(bullet);

                    if (gameChannel) {
                        gameChannel.postMessage({
                            type: 'bullet_fired',
                            id: bullet.id,
                            x: bullet.x,
                            y: bullet.y,
                            angle: bullet.angle,
                            shooterId: bullet.shooterId,
                            bulletSize: bulletSize,
                            bulletRange: bulletRange,
                            createTime: bullet.createTime,
                            timestamp: Date.now()
                        });
                    }
                }
            }

            draw() {
                const screenX = this.x - gameState.camera.x + canvas.width / 2;
                const screenY = this.y - gameState.camera.y + canvas.height / 2;

                if (this.invulnerable) {
                    const blinkSpeed = 200;
                    const isVisible = Math.floor(Date.now() / blinkSpeed) % 2 === 0;
                    if (!isVisible) return;
                }

                if (this.stunned) {
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.sin(Date.now() * 0.05) * 0.2);
                    ctx.translate(-screenX, -screenY);
                }

                ctx.fillStyle = this.alive ? this.color : '#666666';
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = this.alive ? '#ffffff' : '#333333';
                ctx.lineWidth = 2;
                ctx.stroke();

                if (this.stunned) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('â­', screenX, screenY + 5);
                    ctx.restore();
                }

                if (this.invulnerable) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, screenX, screenY - 15);

                // ì´ì•Œ ë ˆë²¨ í‘œì‹œ
                if (this.bulletLevel > 0) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '10px Courier New';
                    ctx.fillText(`âš¡LV${this.bulletLevel}`, screenX, screenY + 20);
                }

                if (!this.alive) {
                    ctx.fillStyle = '#ff4444';
                    ctx.font = '16px Courier New';
                    ctx.fillText('ğŸ’€', screenX, screenY + 5);
                }
            }
        }

        class Monster {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.alive = true;
                this.stunned = false;
                this.stunStart = 0;
                this.angle = 0;
            }

            update() {
                if (!this.alive) return;

                if (this.stunned && Date.now() - this.stunStart > 2000) {
                    this.stunned = false;
                }

                if (!this.stunned) {
                    this.ai();
                }

                this.angle += 0.1;
            }

            ai() {}

            draw() {
                const screenX = this.x - gameState.camera.x + canvas.width / 2;
                const screenY = this.y - gameState.camera.y + canvas.height / 2;

                if (screenX < -50 || screenX > canvas.width + 50 ||
                    screenY < -50 || screenY > canvas.height + 50) {
                    return;
                }

                if (this.stunned) {
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.sin(Date.now() * 0.02) * 0.3);
                    ctx.translate(-screenX, -screenY);
                    ctx.fillStyle = '#666666';
                } else {
                    ctx.fillStyle = this.color;
                }

                this.drawShape(screenX, screenY);

                if (this.stunned) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('ğŸ’«', screenX, screenY - 20);
                    ctx.restore();
                }
            }
        }

        class Observer extends Monster {
            constructor(x, y) {
                super(x, y, 'observer');
                this.size = 15;
                this.speed = 1.5;
                this.color = '#ff6600';
            }

            ai() {
                let closestPlayer = null;
                let closestDistance = Infinity;

                gameState.players.forEach(player => {
                    if (player.alive && !player.invulnerable) {
                        const distance = Math.sqrt(
                            Math.pow(player.x - this.x, 2) +
                            Math.pow(player.y - this.y, 2)
                        );
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestPlayer = player;
                        }
                    }
                });

                if (closestPlayer) {
                    const dx = closestPlayer.x - this.x;
                    const dy = closestPlayer.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                }
            }

            drawShape(screenX, screenY) {
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.angle);

                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#ffaa44';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * this.size, Math.sin(angle) * this.size);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        class Rusher extends Monster {
            constructor(x, y) {
                super(x, y, 'rusher');
                this.size = 10;
                this.speed = 4;
                this.color = '#ff3333';
                this.rushTarget = null;
                this.rushCooldown = 0;
            }

            ai() {
                const now = Date.now();

                if (now - this.rushCooldown > 3000) {
                    let closestPlayer = null;
                    let closestDistance = Infinity;

                    gameState.players.forEach(player => {
                        if (player.alive) {
                            const distance = Math.sqrt(
                                Math.pow(player.x - this.x, 2) +
                                Math.pow(player.y - this.y, 2)
                            );
                            if (distance < closestDistance && distance < 300) {
                                closestDistance = distance;
                                closestPlayer = player;
                            }
                        }
                    });

                    if (closestPlayer) {
                        this.rushTarget = { x: closestPlayer.x, y: closestPlayer.y };
                        this.rushCooldown = now;
                    }
                }

                if (this.rushTarget) {
                    const dx = this.rushTarget.x - this.x;
                    const dy = this.rushTarget.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 5) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    } else {
                        this.rushTarget = null;
                    }
                }
            }

            drawShape(screenX, screenY) {
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + this.angle;
                    const startX = screenX + Math.cos(angle) * this.size;
                    const startY = screenY + Math.sin(angle) * this.size;
                    const endX = screenX + Math.cos(angle) * (this.size + 5);
                    const endY = screenY + Math.sin(angle) * (this.size + 5);

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            }
        }

        class Patroller extends Monster {
            constructor(x, y) {
                super(x, y, 'patroller');
                this.size = 12;
                this.speed = 2;
                this.color = '#9933ff';
                this.patrolTarget = { x: x + Math.random() * 200 - 100, y: y + Math.random() * 200 - 100 };
                this.patrolRadius = 150;
                this.centerX = x;
                this.centerY = y;
            }

            ai() {
                const dx = this.patrolTarget.x - this.x;
                const dy = this.patrolTarget.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 20) {
                    const angle = Math.random() * Math.PI * 2;
                    this.patrolTarget = {
                        x: this.centerX + Math.cos(angle) * this.patrolRadius,
                        y: this.centerY + Math.sin(angle) * this.patrolRadius
                    };
                } else {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
            }

            drawShape(screenX, screenY) {
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.angle);

                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);

                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, angle, shooterId, bulletSize = 3, bulletRange = 20) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 8;
                this.shooterId = shooterId;
                this.size = bulletSize;
                this.range = bulletRange; // ì¶©ëŒ íŒì • ë²”ìœ„
                this.life = 1000;
                this.createTime = Date.now();
                this.trailPoints = []; // ê¶¤ì  íš¨ê³¼
            }

            update() {
                // ê¶¤ì  ì¶”ê°€
                this.trailPoints.push({ x: this.x, y: this.y });
                if (this.trailPoints.length > 5) {
                    this.trailPoints.shift();
                }

                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                if (Date.now() - this.createTime > this.life) {
                    return false;
                }

                return true;
            }

            draw() {
                const screenX = this.x - gameState.camera.x + canvas.width / 2;
                const screenY = this.y - gameState.camera.y + canvas.height / 2;

                // ê¶¤ì  ê·¸ë¦¬ê¸°
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.lineWidth = this.size * 0.5;
                ctx.beginPath();
                for (let i = 0; i < this.trailPoints.length; i++) {
                    const point = this.trailPoints[i];
                    const trailScreenX = point.x - gameState.camera.x + canvas.width / 2;
                    const trailScreenY = point.y - gameState.camera.y + canvas.height / 2;

                    if (i === 0) {
                        ctx.moveTo(trailScreenX, trailScreenY);
                    } else {
                        ctx.lineTo(trailScreenX, trailScreenY);
                    }
                }
                ctx.stroke();

                // ì´ì•Œ ë³¸ì²´ (í¬ê¸°ì— ë”°ë¼ ìƒ‰ìƒ ë³€í™”)
                const intensity = Math.min(this.size / 6, 1); // ìµœëŒ€ 6ì¼ ë•Œ ìµœê³  ë°ê¸°
                ctx.fillStyle = `rgb(${255}, ${255}, ${Math.floor(255 * intensity)})`;
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();

                // ê´‘ì±„ íš¨ê³¼ (ë ˆë²¨ì´ ë†’ì„ìˆ˜ë¡ ê°•í•¨)
                if (this.size > 3) {
                    ctx.fillStyle = `rgba(255, 255, 0, ${0.3 * intensity})`;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ê¼¬ë¦¬ íš¨ê³¼
                ctx.strokeStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.lineWidth = this.size * 0.3;
                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(
                    screenX - Math.cos(this.angle) * (10 + this.size),
                    screenY - Math.sin(this.angle) * (10 + this.size)
                );
                ctx.stroke();
            }
        }

        function initRealtimeSync() {
            try {
                gameChannel = new BroadcastChannel('game_' + gameState.roomId);

                gameChannel.onmessage = (event) => {
                    handleGameMessage(event.data);
                };

                console.log('BroadcastChannel ì—°ê²° ì„±ê³µ');

                // 60fps ë™ê¸°í™” (16ms)
                setInterval(broadcastMyPlayer, 16);

                // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ê°€ ì›”ë“œ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì¸í„°ë²Œì„ ê°€ì§€ì§€ë§Œ,
                // broadcastGameWorld í•¨ìˆ˜ ë‚´ì—ì„œ í˜¸ìŠ¤íŠ¸ë§Œ ì‹¤ì œë¡œ ì „ì†¡í•¨.
                setInterval(broadcastGameWorld, 16);

            } catch (error) {
                console.log('BroadcastChannel ë¯¸ì§€ì›, localStorageë¡œ í´ë°±');
                initLocalStorageSync();
            }
        }

        function handleGameMessage(data) {
            switch(data.type) {
                case 'player_update':
                    if (data.playerId !== gameState.myPlayerId) {
                        updateOtherPlayer(data);
                    }
                    break;

                case 'world_update':
                    if (!gameState.isHost) {
                        updateGameWorld(data);
                    }
                    break;

                case 'bullet_fired':
                    if (data.shooterId !== gameState.myPlayerId) {
                        addBullet(data);
                    }
                    break;

                case 'player_joined':
                    console.log('ìƒˆ í”Œë ˆì´ì–´ ì°¸ê°€:', data.playerName);
                    break;

                case 'player_respawn':
                    if (gameState.isHost) {
                        const player = gameState.players.get(data.playerId);
                        if (player) {
                            player.alive = true;
                            player.invulnerable = true;
                            player.invulnerabilityStart = Date.now();
                            console.log(`${player.name}ì´(ê°€) ë¶€í™œí–ˆìŠµë‹ˆë‹¤.`);
                        }
                    }
                    break;
            }
        }

        function broadcastMyPlayer() {
            if (!gameChannel || Date.now() - lastBroadcast < 12) return; // 12ms ì“°ë¡œí‹€ë§

            const myPlayer = gameState.players.get(gameState.myPlayerId);
            if (!myPlayer) return;

            gameChannel.postMessage({
                type: 'player_update',
                playerId: myPlayer.id,
                playerName: myPlayer.name,
                x: myPlayer.x,
                y: myPlayer.y,
                color: myPlayer.color,
                alive: myPlayer.alive,
                score: myPlayer.score,
                bullets: myPlayer.bulletLevel,
                invulnerable: myPlayer.invulnerable,
                stunned: myPlayer.stunned,
                timestamp: Date.now()
            });

            lastBroadcast = Date.now();
        }

        function updateOtherPlayer(data) {
            // ë°©ì–´ ì½”ë“œ: ìê¸° ìì‹ ì˜ ì •ë³´ëŠ” ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŒ
            if (data.playerId === gameState.myPlayerId) {
                console.warn('updateOtherPlayer was called with my own ID. Ignoring.');
                return;
            }

            if (!gameState.players.has(data.playerId)) {
                const newPlayer = new Player(
                    data.playerId,
                    data.playerName,
                    data.x,
                    data.y,
                    data.color
                );
                gameState.players.set(data.playerId, newPlayer);
            } else {
                const player = gameState.players.get(data.playerId);
                player.x = data.x;
                player.y = data.y;
                player.alive = data.alive;
                player.score = data.score;
                player.bullets = data.bullets;
                player.invulnerable = data.invulnerable;
                player.stunned = data.stunned;
            }
        }

        function broadcastGameWorld() {
            if (!gameChannel || !gameState.isHost) return;

            gameChannel.postMessage({
                type: 'world_update',
                hostId: gameState.hostId, // í˜„ì¬ í˜¸ìŠ¤íŠ¸ ID ì „íŒŒ
                players: Array.from(gameState.players.values()), // ëª¨ë“  í”Œë ˆì´ì–´ ìƒíƒœ ì¶”ê°€
                monsters: gameState.monsters.map(m => ({
                    id: m.id,
                    type: m.type,
                    x: m.x,
                    y: m.y,
                    alive: m.alive,
                    stunned: m.stunned,
                    stunStart: m.stunStart,
                    angle: m.angle
                })),
                bullets: gameState.bullets.map(b => ({
                    id: b.id,
                    x: b.x,
                    y: b.y,
                    angle: b.angle,
                    shooterId: b.shooterId,
                    createTime: b.createTime
                })),
                gameStartTime: gameState.gameStartTime,
                timestamp: Date.now()
            });
        }

        function updateGameWorld(data) {
            if (data.hostId) {
                gameState.hostId = data.hostId;
            }

            // í˜¸ìŠ¤íŠ¸ê°€ ë³´ë‚¸ í”Œë ˆì´ì–´ ëª©ë¡ìœ¼ë¡œ ë¡œì»¬ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
            if (data.players) {
                const receivedPlayerIds = new Set();
                data.players.forEach(playerData => {
                    receivedPlayerIds.add(playerData.id);

                    if (playerData.id === gameState.myPlayerId) {
                        // ë‚´ í”Œë ˆì´ì–´ ì •ë³´ ì—…ë°ì´íŠ¸ (ìœ„ì¹˜ëŠ” ì œì™¸)
                        const myPlayer = gameState.players.get(gameState.myPlayerId);
                        if (myPlayer) {
                            // í˜¸ìŠ¤íŠ¸ê°€ ë‚´ê°€ ì£½ì—ˆë‹¤ê³  í•˜ë©´, ê²Œì„ì˜¤ë²„ ì²˜ë¦¬
                            if (myPlayer.alive && !playerData.alive) {
                                showGameOver();
                            }
                            myPlayer.alive = playerData.alive;
                            myPlayer.score = playerData.score;
                            myPlayer.stunned = playerData.stunned;
                            myPlayer.invulnerable = playerData.invulnerable;
                            myPlayer.bulletLevel = playerData.bulletLevel;
                        }
                    } else {
                        // ë‹¤ë¥¸ í”Œë ˆì´ì–´ ì •ë³´ ì—…ë°ì´íŠ¸
                        if (!gameState.players.has(playerData.id)) {
                            // ìƒˆë¡œìš´ í”Œë ˆì´ì–´ ì¶”ê°€
                            const newPlayer = new Player(playerData.id, playerData.name, playerData.x, playerData.y, playerData.color);
                            gameState.players.set(playerData.id, newPlayer);
                        }
                        const player = gameState.players.get(playerData.id);
                        if (player) {
                            player.x = playerData.x;
                            player.y = playerData.y;
                            player.alive = playerData.alive;
                            player.score = playerData.score;
                            player.stunned = playerData.stunned;
                            player.invulnerable = playerData.invulnerable;
                            player.bulletLevel = playerData.bulletLevel;
                        }
                    }
                });

                // í˜¸ìŠ¤íŠ¸ê°€ ë³´ë‚¸ ëª©ë¡ì— ì—†ëŠ”ë° ë¡œì»¬ì— ìˆëŠ” í”Œë ˆì´ì–´ëŠ” ì‚­ì œ (ì—°ê²° ëŠê¹€)
                gameState.players.forEach(player => {
                    if (player.id === gameState.myPlayerId) return; // ìê¸° ìì‹ ì€ ì‚­ì œí•˜ì§€ ì•ŠìŒ
                    if (!receivedPlayerIds.has(player.id)) {
                        gameState.players.delete(player.id);
                    }
                });
            }

            // ëª¬ìŠ¤í„°ì™€ ì´ì•Œ ì •ë³´ëŠ” ê¸°ì¡´ê³¼ ë™ì¼í•˜ê²Œ ì—…ë°ì´íŠ¸
            gameState.monsters = data.monsters.map(monsterData => {
                let monster;
                switch(monsterData.type) {
                    case 'observer':
                        monster = new Observer(monsterData.x, monsterData.y);
                        break;
                    case 'rusher':
                        monster = new Rusher(monsterData.x, monsterData.y);
                        break;
                    case 'patroller':
                        monster = new Patroller(monsterData.x, monsterData.y);
                        break;
                    default:
                        monster = new Observer(monsterData.x, monsterData.y);
                }
                monster.id = monsterData.id;
                monster.x = monsterData.x;
                monster.y = monsterData.y;
                monster.alive = monsterData.alive;
                monster.stunned = monsterData.stunned;
                monster.stunStart = monsterData.stunStart;
                monster.angle = monsterData.angle;
                return monster;
            });

            gameState.bullets = data.bullets.map(bulletData => {
                const bullet = new Bullet(bulletData.x, bulletData.y, bulletData.angle, bulletData.shooterId);
                bullet.id = bulletData.id;
                bullet.createTime = bulletData.createTime;
                return bullet;
            });

            if (data.gameStartTime && !gameState.gameStartTime) {
                gameState.gameStartTime = data.gameStartTime;
            }
        }

        function addBullet(data) {
            const bullet = new Bullet(data.x, data.y, data.angle, data.shooterId, data.bulletSize, data.bulletRange);
            bullet.id = data.id;
            bullet.createTime = data.createTime;
            gameState.bullets.push(bullet);
        }

        function spawnMonster() {
            const now = Date.now();
            const timeSinceStart = (now - gameState.gameStartTime) / 1000;
            const spawnInterval = Math.max(1000 - (timeSinceStart * 30), 200);

            if (now - gameState.lastMonsterSpawn > spawnInterval) {
                const players = Array.from(gameState.players.values());
                if (players.length === 0) return; // í”Œë ˆì´ì–´ê°€ ì•„ë¬´ë„ ì—†ìœ¼ë©´ ìŠ¤í°í•˜ì§€ ì•ŠìŒ

                const livingPlayers = players.filter(p => p.alive);

                let spawnTargetPlayer;
                if (livingPlayers.length > 0) {
                    // ì‚´ì•„ìˆëŠ” í”Œë ˆì´ì–´ ì£¼ë³€ì— ìŠ¤í°
                    spawnTargetPlayer = livingPlayers[Math.floor(Math.random() * livingPlayers.length)];
                } else {
                    // ëª¨ë‘ ì£½ì—ˆë‹¤ë©´, ë¬´ì‘ìœ„ í”Œë ˆì´ì–´ì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ ì£¼ë³€ì— ìŠ¤í°
                    spawnTargetPlayer = players[Math.floor(Math.random() * players.length)];
                }

                const spawnCount = Math.min(Math.floor(timeSinceStart / 10) + 1, 5);

                for (let i = 0; i < spawnCount; i++) {
                    const spawnDistance = 300 + Math.random() * 200;
                    const angle = Math.random() * Math.PI * 2;
                    const x = spawnTargetPlayer.x + Math.cos(angle) * spawnDistance;
                    const y = spawnTargetPlayer.y + Math.sin(angle) * spawnDistance;

                    const monsterTypes = [Observer, Rusher, Patroller];
                    const weights = [0.4, 0.4, 0.2];

                    let random = Math.random();
                    let MonsterClass = Observer;

                    for (let j = 0; j < weights.length; j++) {
                        if (random < weights[j]) {
                            MonsterClass = monsterTypes[j];
                            break;
                        }
                        random -= weights[j];
                    }

                    const monster = new MonsterClass(x, y);
                    monster.id = 'monster_' + Date.now() + '_' + Math.random();
                    gameState.monsters.push(monster);
                }

                gameState.lastMonsterSpawn = now;
            }
        }

        function checkCollisions() {
            gameState.players.forEach(player => {
                if (!player.alive || player.invulnerable) return;

                gameState.monsters.forEach(monster => {
                    if (!monster.alive) return;

                    const distance = Math.sqrt(
                        Math.pow(player.x - monster.x, 2) +
                        Math.pow(player.y - monster.y, 2)
                    );

                    if (distance < player.size + monster.size - 5) {
                        player.alive = false;

                        if (player.id === gameState.myPlayerId) {
                            showGameOver();
                        }
                    }
                });
            });

            const playerArray = Array.from(gameState.players.values());
            for (let i = 0; i < playerArray.length; i++) {
                for (let j = i + 1; j < playerArray.length; j++) {
                    const p1 = playerArray[i];
                    const p2 = playerArray[j];

                    if (!p1.alive || !p2.alive) continue;

                    const distance = Math.sqrt(
                        Math.pow(p1.x - p2.x, 2) +
                        Math.pow(p1.y - p2.y, 2)
                    );

                    if (distance < p1.size + p2.size) {
                        p1.stunned = true;
                        p1.stunStart = Date.now();
                        p2.stunned = true;
                        p2.stunStart = Date.now();

                        const pushForce = 20;
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 0) {
                            p1.x -= (dx / dist) * pushForce;
                            p1.y -= (dy / dist) * pushForce;
                            p2.x += (dx / dist) * pushForce;
                            p2.y += (dy / dist) * pushForce;
                        }
                    }
                }
            }

            gameState.bullets.forEach((bullet, bulletIndex) => {
                gameState.players.forEach(player => {
                    if (player.id === bullet.shooterId || !player.alive) return;

                    const distance = Math.sqrt(
                        Math.pow(player.x - bullet.x, 2) +
                        Math.pow(player.y - bullet.y, 2)
                    );

                    // ì´ì•Œ ë ˆë²¨ì— ë”°ë¥¸ ì¶©ëŒ ë²”ìœ„ ì‚¬ìš©
                    if (distance < player.size + bullet.range) {
                        player.stunned = true;
                        player.stunStart = Date.now();
                        gameState.bullets.splice(bulletIndex, 1);
                    }
                });

                gameState.monsters.forEach(monster => {
                    if (!monster.alive) return;

                    const distance = Math.sqrt(
                        Math.pow(monster.x - bullet.x, 2) +
                        Math.pow(monster.y - bullet.y, 2)
                    );

                    // ì´ì•Œ ë ˆë²¨ì— ë”°ë¥¸ ì¶©ëŒ ë²”ìœ„ ì‚¬ìš©
                    if (distance < monster.size + bullet.range) {
                        monster.stunned = true;
                        monster.stunStart = Date.now();
                        gameState.bullets.splice(bulletIndex, 1);
                    }
                });
            });
        }

        function showGameOver() {
            const myPlayer = gameState.players.get(gameState.myPlayerId);
            document.getElementById('finalScore').textContent =
                `ìµœì¢… ì ìˆ˜: ${myPlayer.score}ì  (ìƒì¡´ ì‹œê°„: ${Math.floor(myPlayer.score / 10)}ì´ˆ)`;
            document.getElementById('gameOver').style.display = 'flex';
        }

        function respawn() {
            const myPlayer = gameState.players.get(gameState.myPlayerId);
            myPlayer.alive = true;
            myPlayer.invulnerable = true;
            myPlayer.invulnerabilityStart = Date.now();

            let safeX, safeY;
            let attempts = 0;
            do {
                safeX = myPlayer.x + (Math.random() - 0.5) * 200;
                safeY = myPlayer.y + (Math.random() - 0.5) * 200;
                attempts++;
            } while (attempts < 20 && isTooCloseToMonsters(safeX, safeY));

            myPlayer.x = safeX;
            myPlayer.y = safeY;

            document.getElementById('gameOver').style.display = 'none';
            gameState.gameStartTime = Date.now();

            if (gameChannel) {
                gameChannel.postMessage({ type: 'player_respawn', playerId: myPlayer.id });
            } else {
                // localStorage í´ë°±ì„ ìœ„í•œ ì´ë²¤íŠ¸ ê¸°ë¡
                const eventKey = 'event_respawn_' + gameState.myPlayerId + '_' + Date.now();
                localStorage.setItem(eventKey, JSON.stringify({ playerId: gameState.myPlayerId }));
            }
        }

        function isTooCloseToMonsters(x, y) {
            return gameState.monsters.some(monster => {
                const distance = Math.sqrt(
                    Math.pow(x - monster.x, 2) +
                    Math.pow(y - monster.y, 2)
                );
                return distance < 100;
            });
        }

        function updatePlayerList() {
            const playersDiv = document.getElementById('players');
            playersDiv.innerHTML = '';

            const sortedPlayers = Array.from(gameState.players.values())
                .sort((a, b) => b.score - a.score);

            sortedPlayers.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.style.color = player.color;
                playerDiv.style.margin = '2px 0';
                playerDiv.innerHTML = `
                    ${index + 1}. ${player.name}
                    ${player.alive ? 'ğŸŸ¢' : 'ğŸ’€'}
                    (${player.score}ì )
                `;
                playersDiv.appendChild(playerDiv);
            });
        }

        function updateUI() {
            if (!gameState.gameRunning) return;

            const timeSurvived = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            document.getElementById('timeDisplay').textContent = timeSurvived;
            document.getElementById('observerCount').textContent = gameState.monsters.length;

            const myPlayer = gameState.players.get(gameState.myPlayerId);
            if (myPlayer) {
                document.getElementById('myScore').textContent = myPlayer.score;
            }
        }

        function updateCamera() {
            const myPlayer = gameState.players.get(gameState.myPlayerId);
            if (myPlayer && myPlayer.alive) {
                const lerp = 0.1;
                gameState.camera.x += (myPlayer.x - gameState.camera.x) * lerp;
                gameState.camera.y += (myPlayer.y - gameState.camera.y) * lerp;
            }
        }

        function gameLoop() {
            // í˜¸ìŠ¤íŠ¸ëŠ” ëª¨ë“  ê²Œì„ ë¡œì§(ìŠ¤í°, ì—…ë°ì´íŠ¸, ì¶©ëŒ)ì— ëŒ€í•œ ê¶Œí•œì„ ê°€ì§
            if (gameState.isHost) {
                spawnMonster();
                gameState.monsters.forEach(monster => monster.update());
                gameState.bullets = gameState.bullets.filter(bullet => bullet.update());
                checkCollisions(); // ëª¨ë“  ì¶©ëŒ ê³„ì‚°ì€ í˜¸ìŠ¤íŠ¸ë§Œ ìˆ˜í–‰

                // ì‹œì•¼ì—ì„œ ë„ˆë¬´ ë©€ë¦¬ ë–¨ì–´ì§„ ëª¬ìŠ¤í„° ì •ë¦¬
                const anyPlayer = Array.from(gameState.players.values()).find(p => p.alive);
                if (anyPlayer) {
                    gameState.monsters = gameState.monsters.filter(monster => {
                        const distance = Math.sqrt(
                            Math.pow(monster.x - anyPlayer.x, 2) +
                            Math.pow(monster.y - anyPlayer.y, 2)
                        );
                        return distance < 1500; // ì‹œì•¼ ë²”ìœ„ ì†Œí­ ì¦ê°€
                    });
                }
            }

            // ëª¨ë“  í”Œë ˆì´ì–´ëŠ” ìì‹ ì˜ ì…ë ¥ì„ ì²˜ë¦¬ (í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì˜ˆì¸¡)
            const myPlayer = gameState.players.get(gameState.myPlayerId);
            if (myPlayer && myPlayer.alive) {
                myPlayer.update();
            }

            // ë Œë”ë§ì€ í•­ìƒ ìˆ˜í–‰ (ê´€ì „ ëª¨ë“œë¥¼ ìœ„í•´)
            ctx.fillStyle = '#000428';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < 100; i++) {
                const starX = (Math.sin(i * 12.9898) * 43758.5453) % gameState.mapSize.width;
                const starY = (Math.cos(i * 78.233) * 43758.5453) % gameState.mapSize.height;
                const screenX = starX - gameState.camera.x + canvas.width / 2;
                const screenY = starY - gameState.camera.y + canvas.height / 2;

                if (screenX >= 0 && screenX <= canvas.width &&
                    screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(i) * 0.2})`;
                    ctx.fillRect(screenX, screenY, 1, 1);
                }
            }

            updateCamera();

            gameState.monsters.forEach(monster => monster.draw());
            gameState.bullets.forEach(bullet => bullet.draw());
            gameState.players.forEach(player => player.draw());

            updateUI();
            updatePlayerList();

            requestAnimationFrame(gameLoop);
        }

        function joinGame() {
            const nameInput = document.getElementById('playerName');
            const name = nameInput.value.trim();

            if (!name) {
                alert('ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”!');
                return;
            }

            const urlParams = new URLSearchParams(window.location.search);
            let roomId = urlParams.get('room');

            if (!roomId) {
                roomId = 'room_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                gameState.isHost = true;

                try {
                    const newUrl = window.location.protocol + '//' + window.location.host + window.location.pathname + '?room=' + roomId;
                    window.history.pushState({path: newUrl}, '', newUrl);
                    showRoomLink(newUrl);
                } catch (error) {
                    const simulatedUrl = 'https://yourusername.github.io/your-game?room=' + roomId;
                    showRoomLink(simulatedUrl);
                    console.log('ì‹¤ì œ ë°°í¬ ì‹œ ì‚¬ìš©í•  ë°© ID:', roomId);
                }
            }

            gameState.roomId = roomId;

            const statusElement = document.getElementById('connectionStatus');
            if (statusElement) {
                statusElement.textContent = gameState.isHost ? 'ë°©ì¥ (í˜¸ìŠ¤íŠ¸)' : 'ì°¸ê°€ì';
                statusElement.style.color = gameState.isHost ? '#ffaa00' : '#00ff00';
            }

            document.getElementById('joinForm').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('gameUI').style.display = 'block';
            document.getElementById('playerList').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';

            const playerId = 'player_' + Date.now() + '_' + Math.random();
            if (gameState.isHost) {
                gameState.hostId = playerId;
            }
            const playerColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
            const startX = 400;
            const startY = 400;

            const player = new Player(playerId, name, startX, startY, playerColor);
            gameState.players.set(playerId, player);
            gameState.myPlayerId = playerId;
            gameState.gameRunning = true;
            gameState.gameStartTime = Date.now();

            initRealtimeSync();

            setTimeout(() => {
                if (gameChannel) {
                    gameChannel.postMessage({
                        type: 'player_joined',
                        playerId: playerId,
                        playerName: name,
                        timestamp: Date.now()
                    });
                }
            }, 100);

            gameLoop();
        }

        function showRoomLink(url) {
            const linkDiv = document.createElement('div');
            linkDiv.style.position = 'fixed';
            linkDiv.style.top = '10px';
            linkDiv.style.left = '50%';
            linkDiv.style.transform = 'translateX(-50%)';
            linkDiv.style.background = 'rgba(0, 0, 0, 0.9)';
            linkDiv.style.color = '#00ff00';
            linkDiv.style.padding = '10px';
            linkDiv.style.borderRadius = '5px';
            linkDiv.style.border = '1px solid #00ff41';
            linkDiv.style.zIndex = '100';
            linkDiv.style.textAlign = 'center';
            linkDiv.innerHTML = `
                <div>ì¹œêµ¬ë“¤ê³¼ í•¨ê»˜ í”Œë ˆì´í•˜ë ¤ë©´ ì´ ë§í¬ë¥¼ ê³µìœ í•˜ì„¸ìš”:</div>
                <input type="text" value="${url}" readonly style="width: 400px; margin: 5px; padding: 5px; background: #000; color: #00ff00; border: 1px solid #00ff41;">
                <button onclick="copyToClipboard('${url}')" style="margin: 5px; padding: 5px 10px; background: #004e92; color: #00ff00; border: 1px solid #00ff41; cursor: pointer;">ë³µì‚¬</button>
                <button onclick="this.parentElement.remove()" style="margin: 5px; padding: 5px 10px; background: #004e92; color: #00ff00; border: 1px solid #00ff41; cursor: pointer;">ë‹«ê¸°</button>
                <div style="font-size: 10px; margin-top: 10px; color: #888;">
                    ğŸ’¡ í˜„ì¬ Claude í™˜ê²½ì—ì„œëŠ” URL ë§í¬ê°€ ì œí•œë©ë‹ˆë‹¤.<br>
                    GitHub.ioì— ë°°í¬í•˜ë©´ ì‹¤ì œ ë§í¬ë¡œ ì¹œêµ¬ ì´ˆëŒ€ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤!<br>
                    ì§€ê¸ˆì€ ê°™ì€ ë¸Œë¼ìš°ì €ì—ì„œ ìƒˆ íƒ­ì„ ì—´ì–´ì„œ í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”.<br>
                    ğŸš€ BroadcastChannel APIë¡œ ì‹¤ì‹œê°„ ë™ê¸°í™”ë©ë‹ˆë‹¤!
                </div>
            `;
            document.body.appendChild(linkDiv);
        }

        function copyToClipboard(text) {
            try {
                navigator.clipboard.writeText(text).then(() => {
                    alert('ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
                }).catch(() => {
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    alert('ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
                });
            } catch (error) {
                alert('ë§í¬ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”: ' + text);
            }
        }

        function initLocalStorageSync() {
            console.log('localStorage ë™ê¸°í™” ì‚¬ìš© (60fps)');

            // 1. ìì‹ ì˜ í”Œë ˆì´ì–´ ì •ë³´ë¥¼ 60fpsë¡œ ì €ì¥
            setInterval(() => {
                const myPlayer = gameState.players.get(gameState.myPlayerId);
                if (myPlayer) {
                    localStorage.setItem('player_' + gameState.myPlayerId, JSON.stringify({
                        id: myPlayer.id,
                        name: myPlayer.name,
                        x: myPlayer.x,
                        y: myPlayer.y,
                        color: myPlayer.color,
                        alive: myPlayer.alive,
                        score: myPlayer.score,
                        bullets: myPlayer.bullets,
                        invulnerable: myPlayer.invulnerable,
                        stunned: myPlayer.stunned,
                        timestamp: Date.now()
                    }));
                }
            }, 16);

            // 2. í˜¸ìŠ¤íŠ¸ëŠ” ê²Œì„ ì›”ë“œ ì •ë³´ë¥¼ 60fpsë¡œ ì €ì¥
            setInterval(() => {
                if (gameState.isHost) {
                    localStorage.setItem('gameWorld_' + gameState.roomId, JSON.stringify({
                        players: Array.from(gameState.players.values()),
                        monsters: gameState.monsters.map(m => ({
                            id: m.id,
                            type: m.type,
                            x: m.x,
                            y: m.y,
                            alive: m.alive,
                            stunned: m.stunned,
                            stunStart: m.stunStart,
                            angle: m.angle
                        })),
                        bullets: gameState.bullets.map(b => ({
                            id: b.id,
                            x: b.x,
                            y: b.y,
                            angle: b.angle,
                            shooterId: b.shooterId,
                            bulletSize: b.size,
                            bulletRange: b.range,
                            createTime: b.createTime
                        })),
                        gameStartTime: gameState.gameStartTime,
                        hostId: gameState.hostId,
                        timestamp: Date.now()
                    }));
                }
            }, 16);

            // 3. ë‹¤ë¥¸ í”Œë ˆì´ì–´ ì •ë³´ì™€ ì›”ë“œ ì •ë³´ë¥¼ 60fpsë¡œ í™•ì¸
            setInterval(() => {
                if (gameState.isHost) {
                    // ë¦¬ìŠ¤í° ì´ë²¤íŠ¸ í™•ì¸ (localStorage í´ë°±ìš©)
                    const storageKeys = Object.keys(localStorage);
                    const respawnEvents = storageKeys.filter(key => key.startsWith('event_respawn_'));
                    respawnEvents.forEach(key => {
                        try {
                            const eventData = JSON.parse(localStorage.getItem(key));
                            const player = gameState.players.get(eventData.playerId);
                            if (player) {
                                player.alive = true;
                                player.invulnerable = true;
                                player.invulnerabilityStart = Date.now();
                                console.log(`${player.name}ì´(ê°€) ë¶€í™œí–ˆìŠµë‹ˆë‹¤. (localStorage)`);
                            }
                        } catch(e) { console.error('localStorage ì´ë²¤íŠ¸ ì²˜ë¦¬ ì˜¤ë¥˜:', e); }
                        localStorage.removeItem(key); // ì²˜ë¦¬ëœ ì´ë²¤íŠ¸ëŠ” ì‚­ì œ
                    });
                }

                checkOtherPlayersInStorage();
                if (!gameState.isHost) {
                    checkGameWorldInStorage();
                }
            }, 16);
        }

        function checkOtherPlayersInStorage() {
            const storageKeys = Object.keys(localStorage);
            const myPlayerKey = 'player_' + gameState.myPlayerId;
            const playerKeys = storageKeys.filter(key => key.startsWith('player_') && key !== myPlayerKey);

            playerKeys.forEach(key => {
                try {
                    const playerData = JSON.parse(localStorage.getItem(key));
                    const timeDiff = Date.now() - playerData.timestamp;

                    if (timeDiff < 5000) {
                        if (!gameState.players.has(playerData.id)) {
                            const newPlayer = new Player(
                                playerData.id,
                                playerData.name,
                                playerData.x,
                                playerData.y,
                                playerData.color
                            );
                            newPlayer.alive = playerData.alive;
                            newPlayer.score = playerData.score;
                            newPlayer.bullets = playerData.bullets;
                            newPlayer.invulnerable = playerData.invulnerable;
                            newPlayer.stunned = playerData.stunned;
                            gameState.players.set(playerData.id, newPlayer);
                            console.log('ìƒˆ í”Œë ˆì´ì–´ ë°œê²¬:', playerData.name);
                        } else {
                            const existingPlayer = gameState.players.get(playerData.id);
                            existingPlayer.x = playerData.x;
                            existingPlayer.y = playerData.y;
                            existingPlayer.alive = playerData.alive;
                            existingPlayer.score = playerData.score;
                            existingPlayer.bullets = playerData.bullets;
                            existingPlayer.invulnerable = playerData.invulnerable;
                            existingPlayer.stunned = playerData.stunned;
                        }
                    } else {
                        if (gameState.players.has(playerData.id)) {
                            console.log('í”Œë ˆì´ì–´ ì—°ê²° ëŠê¹€:', gameState.players.get(playerData.id).name);
                            gameState.players.delete(playerData.id);
                            localStorage.removeItem(key);

                            // í˜¸ìŠ¤íŠ¸ê°€ ë‚˜ê°”ëŠ”ì§€ í™•ì¸
                            if (playerData.id === gameState.hostId) {
                                console.log('í˜¸ìŠ¤íŠ¸ ì—°ê²°ì´ ëŠê²¼ìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ í˜¸ìŠ¤íŠ¸ë¥¼ ì„ ì¶œí•©ë‹ˆë‹¤.');
                                electNewHost();
                            }
                        }
                    }
                } catch (error) {
                    console.error('í”Œë ˆì´ì–´ ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
                    localStorage.removeItem(key);
                }
            });
        }

        function checkGameWorldInStorage() {
            try {
                const worldData = localStorage.getItem('gameWorld_' + gameState.roomId);
                if (!worldData) return;

                const gameWorld = JSON.parse(worldData);
                const timeDiff = Date.now() - gameWorld.timestamp;

                if (timeDiff < 3000) {
                    // í”Œë ˆì´ì–´ ì •ë³´ ì—…ë°ì´íŠ¸
                    if (gameWorld.players) {
                        const receivedPlayerIds = new Set();
                        gameWorld.players.forEach(playerData => {
                            receivedPlayerIds.add(playerData.id);

                            if (playerData.id === gameState.myPlayerId) {
                                const myPlayer = gameState.players.get(gameState.myPlayerId);
                                if (myPlayer) {
                                    if (myPlayer.alive && !playerData.alive) {
                                        showGameOver();
                                    }
                                    myPlayer.alive = playerData.alive;
                                    myPlayer.score = playerData.score;
                                    myPlayer.stunned = playerData.stunned;
                                    myPlayer.invulnerable = playerData.invulnerable;
                                    myPlayer.bulletLevel = playerData.bulletLevel;
                                }
                            } else {
                                if (!gameState.players.has(playerData.id)) {
                                    const newPlayer = new Player(playerData.id, playerData.name, playerData.x, playerData.y, playerData.color);
                                    gameState.players.set(playerData.id, newPlayer);
                                }
                                const player = gameState.players.get(playerData.id);
                                if (player) {
                                    player.x = playerData.x;
                                    player.y = playerData.y;
                                    player.alive = playerData.alive;
                                    player.score = playerData.score;
                                    player.stunned = playerData.stunned;
                                    player.invulnerable = playerData.invulnerable;
                                    player.bulletLevel = playerData.bulletLevel;
                                }
                            }
                        });

                        gameState.players.forEach(player => {
                            if (player.id === gameState.myPlayerId) return; // ìê¸° ìì‹ ì€ ì‚­ì œí•˜ì§€ ì•ŠìŒ
                            if (!receivedPlayerIds.has(player.id)) {
                                gameState.players.delete(player.id);
                            }
                        });
                    }

                    // ëª¬ìŠ¤í„° ë° ì´ì•Œ ì •ë³´ ì—…ë°ì´íŠ¸
                    gameState.monsters = gameWorld.monsters.map(monsterData => {
                        let monster;
                        switch(monsterData.type) {
                            case 'observer':
                                monster = new Observer(monsterData.x, monsterData.y);
                                break;
                            case 'rusher':
                                monster = new Rusher(monsterData.x, monsterData.y);
                                break;
                            case 'patroller':
                                monster = new Patroller(monsterData.x, monsterData.y);
                                break;
                            default:
                                monster = new Observer(monsterData.x, monsterData.y);
                        }
                        monster.id = monsterData.id;
                        monster.x = monsterData.x;
                        monster.y = monsterData.y;
                        monster.alive = monsterData.alive;
                        monster.stunned = monsterData.stunned;
                        monster.stunStart = monsterData.stunStart;
                        monster.angle = monsterData.angle;
                        return monster;
                    });

                    gameState.bullets = gameWorld.bullets.map(bulletData => {
                        const bullet = new Bullet(bulletData.x, bulletData.y, bulletData.angle, bulletData.shooterId);
                        bullet.id = bulletData.id;
                        bullet.createTime = bulletData.createTime;
                        return bullet;
                    });

                    if (gameWorld.gameStartTime && !gameState.gameStartTime) {
                        gameState.gameStartTime = gameWorld.gameStartTime;
                    }
                    if (gameWorld.hostId) {
                        gameState.hostId = gameWorld.hostId;
                    }
                }
            } catch (error) {
                console.error('ê²Œì„ ì›”ë“œ ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
            }
        }

        function electNewHost() {
            const remainingPlayers = Array.from(gameState.players.values());

            if (remainingPlayers.length === 0) {
                gameState.isHost = true;
                gameState.hostId = gameState.myPlayerId;
                console.log('í˜¼ì ë‚¨ì•˜ìŠµë‹ˆë‹¤. ë‚´ê°€ ìƒˆë¡œìš´ í˜¸ìŠ¤íŠ¸ì…ë‹ˆë‹¤.');
                return;
            }

            // IDë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ê°€ì¥ ì˜¤ë˜ëœ í”Œë ˆì´ì–´ë¥¼ ì°¾ìŒ
            remainingPlayers.sort((a, b) => a.id.localeCompare(b.id));
            const newHost = remainingPlayers[0];

            gameState.hostId = newHost.id;

            if (newHost.id === gameState.myPlayerId) {
                if (!gameState.isHost) {
                    gameState.isHost = true;
                    console.log('ë‚´ê°€ ìƒˆë¡œìš´ í˜¸ìŠ¤íŠ¸ë¡œ ì„ ì¶œë˜ì—ˆìŠµë‹ˆë‹¤.');
                }
            } else {
                gameState.isHost = false;
                console.log(`ìƒˆë¡œìš´ í˜¸ìŠ¤íŠ¸: ${newHost.name}`);
            }
        }

        document.addEventListener('keydown', (e) => {
            gameState.keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.code] = false;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // ì°½ì´ í¬ì»¤ìŠ¤ë¥¼ ìƒìœ¼ë©´ ëª¨ë“  í‚¤ ì…ë ¥ì„ ì´ˆê¸°í™” (í‚¤ ì”¹í˜ ë°©ì§€)
        window.addEventListener('blur', () => {
            gameState.keys = {};
        });

        window.addEventListener('beforeunload', () => {
            if (gameState.roomId && gameState.myPlayerId) {a
                localStorage.removeItem('player_' + gameState.myPlayerId);
            }
        });
    </script>
</body>
</html>