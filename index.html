<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>멀티플레이어 몬스터 피하기</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, #0c1445, #1a237e);
        font-family: 'Courier New', monospace;
        color: #00ff00;
        overflow: hidden;
        height: 100vh;
      }

      .game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #gameCanvas {
        background: radial-gradient(circle at center, #000428, #004e92);
        border: 2px solid #00ff41;
        display: block;
        margin: 0 auto;
      }

      .ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #00ff41;
      }

      .player-list {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #00ff41;
        min-width: 200px;
      }

      .join-form {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border-radius: 10px;
        border: 2px solid #00ff41;
        text-align: center;
        z-index: 20;
      }

      input[type='text'] {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #00ff41;
        color: #00ff00;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
        font-family: inherit;
      }

      button {
        background: linear-gradient(45deg, #004e92, #000428);
        border: 2px solid #00ff41;
        color: #00ff00;
        padding: 10px 20px;
        cursor: pointer;
        border-radius: 5px;
        font-family: inherit;
        margin: 5px;
        transition: all 0.3s;
      }

      button:hover {
        background: linear-gradient(45deg, #006bb3, #001845);
        box-shadow: 0 0 10px #00ff41;
      }

      .game-over {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(30, 30, 30, 0.7); /* 회색 반투명 배경 */
        display: none; /* 기본적으로 숨김 */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 15;
        text-align: center;
        color: #ff4444;
      }

      .game-over h2 {
        font-size: 48px;
        text-shadow: 0 0 10px #ff0000;
      }

      .game-over p {
        font-size: 24px;
        margin-bottom: 100px; /* 버튼과의 간격 */
      }

      .respawn-button {
        position: absolute;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 30px;
        font-size: 18px;
        background: linear-gradient(45deg, #ff4444, #b30000);
        border: 2px solid #ff8888;
        color: #ffffff;
      }

      .instructions {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #00ff41;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="join-form" id="joinForm">
        <h2>멀티플레이어 몬스터 피하기</h2>
        <p>닉네임을 입력하세요</p>
        <input type="text" id="playerName" placeholder="닉네임" maxlength="15" />
        <br />
        <button onclick="joinGame()">게임 참가</button>
        <div style="margin-top: 15px; font-size: 12px; color: #888">
          ✨ 서버 없이도 실시간 멀티플레이어!<br />
          🔗 링크를 공유해서 친구들과 함께 플레이하세요<br />
          🎮 현재 상태: <span id="connectionStatus">연결 대기 중...</span>
        </div>
      </div>

      <div class="ui" id="gameUI" style="display: none">
        <div>생존 시간: <span id="timeDisplay">0</span>초</div>
        <div>몬스터 수: <span id="observerCount">0</span></div>
        <div>내 점수: <span id="myScore">0</span></div>
        <div id="levelControl" style="display: none">
          <div>레벨: <span id="levelDisplay">1</span></div>
          <button onclick="changeLevel(-1)">-</button>
          <button onclick="changeLevel(1)">+</button>
        </div>
      </div>

      <div class="player-list" id="playerList" style="display: none">
        <h3>플레이어 목록</h3>
        <div id="players"></div>
      </div>

      <canvas id="gameCanvas" style="display: none"></canvas>

      <div class="game-over" id="gameOver">
        <h2>GAME OVER</h2>
        <p id="finalScore"></p>
        <button class="respawn-button" onclick="respawn()">다시 시작</button>
      </div>

      <div class="instructions" id="instructions" style="display: none">
        화살표 키 또는 WASD로 이동 • 스페이스바로 총 발사 • 몬스터를 피하세요! • 다른 플레이어와 부딪히면 기절!
      </div>

      <div
        id="resetContainer"
        style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 20; display: none"
      >
        <button onclick="resetGame()">모든 몬스터 리셋</button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let gameState = {
          players: new Map(),
          monsters: [],
          bullets: [],
          myPlayerId: null,
          gameStartTime: Date.now(),
          lastMonsterSpawn: 0,
          keys: {},
          gameRunning: false,
          camera: { x: 0, y: 0 },
          mapSize: { width: 2000, height: 2000 },
          lastSpacePress: 0,
          roomId: null,
          isHost: false,
          hostId: null,
          gameLevel: 1,
          debug: true
      };

      let gameChannel = null;
      let lastBroadcast = 0;
      let electionTimeout = null;

      class Player {
          constructor(id, name, x, y, color) {
              this.id = id;
              this.name = name;
              this.x = x;
              this.y = y;
              this.color = color;
              this.alive = true;
              this.score = 0;
              this.size = 8;
              this.speed = 3;
              this.invulnerable = false;
              this.invulnerabilityStart = 0;
              this.stunned = false;
              this.stunStart = 0;
              this.level = 1;
              this.killScore = 0;
              this.speedBonus = 0;
          }

          update() {
              if (!this.alive) return;

              if (this.stunned && Date.now() - this.stunStart > 100) {
                  this.stunned = false;
              }

              if (this.id === gameState.myPlayerId && !this.stunned) {
                  let dx = 0;
                  let dy = 0;

                  if (gameState.keys['ArrowUp'] || gameState.keys['KeyW']) {
                      dy -= 1;
                  }
                  if (gameState.keys['ArrowDown'] || gameState.keys['KeyS']) {
                      dy += 1;
                  }
                  if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) {
                      dx -= 1;
                  }
                  if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) {
                      dx += 1;
                  }

                  if (dx !== 0 || dy !== 0) {
                      const magnitude = Math.sqrt(dx * dx + dy * dy);
                      const normalizedDx = dx / magnitude;
                      const normalizedDy = dy / magnitude;

                      this.x += normalizedDx * (this.speed + this.speedBonus);
                      this.y += normalizedDy * (this.speed + this.speedBonus);

                      const expandMargin = 200;
                      if (this.x > gameState.mapSize.width - expandMargin) {
                          gameState.mapSize.width = this.x + expandMargin;
                      }
                      if (this.y > gameState.mapSize.height - expandMargin) {
                          gameState.mapSize.height = this.y + expandMargin;
                      }
                      if (this.x < expandMargin) {
                          gameState.mapSize.width += expandMargin - this.x;
                          const offset = expandMargin - this.x;
                          gameState.players.forEach(p => p.x += offset);
                          gameState.monsters.forEach(m => m.x += offset);
                          gameState.bullets.forEach(b => b.x += offset);
                          gameState.camera.x += offset;
                      }
                      if (this.y < expandMargin) {
                          gameState.mapSize.height += expandMargin - this.y;
                          const offset = expandMargin - this.y;
                          gameState.players.forEach(p => p.y += offset);
                          gameState.monsters.forEach(m => m.y += offset);
                          gameState.bullets.forEach(b => b.y += offset);
                          gameState.camera.y += offset;
                      }
                  }

                  if (gameState.keys['Space'] &&
                      Date.now() - gameState.lastSpacePress > 200) {
                      this.shootBullet();
                      gameState.lastSpacePress = Date.now();
                  }
              }

              if (this.invulnerable && Date.now() - this.invulnerabilityStart > 3000) {
                  this.invulnerable = false;
              }

              const survivalScore = Math.floor((Date.now() - gameState.gameStartTime) / 100);
              this.score = survivalScore + this.killScore;

              // 레벨 계산
              const score = this.score;
              if (score < 1000) this.level = 1;
              else if (score < 3000) this.level = 2;
              else if (score < 6000) this.level = 3;
              else if (score < 10000) this.level = 4;
              else if (score < 15000) this.level = 5;
              else if (score < 21000) this.level = 6;
              else if (score < 28000) this.level = 7;
              else if (score < 36000) this.level = 8;
              else if (score < 45000) this.level = 9;
              else if (score < 55000) this.level = 10;
              else if (score < 66000) this.level = 11;
              else if (score < 78000) this.level = 12;
              else if (score < 91000) this.level = 13;
              else if (score < 105000) this.level = 14;
              else if (score < 120000) this.level = 15;
              else if (score < 136000) this.level = 16;
              else if (score < 153000) this.level = 17;
              else if (score < 171000) this.level = 18;
              else if (score < 190000) this.level = 19;
              else this.level = 20;

              this.speedBonus = Math.floor(this.level / 3) * 0.1;
          }

          shootBullet() {
              const now = Date.now();
              const rapidFireCooldown = this.level >= 3 ? 100 : 200;

              if (now - gameState.lastSpacePress < rapidFireCooldown) {
                  return;
              }

              let closestTarget = null;
              let closestDistance = Infinity;

              // Find closest target
              gameState.players.forEach(player => {
                  if (player.id !== this.id && player.alive) {
                      const distance = Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2));
                      if (distance < closestDistance && distance < 300) { // Increased target range
                          closestDistance = distance;
                          closestTarget = player;
                      }
                  }
              });
              gameState.monsters.forEach(monster => {
                  const distance = Math.sqrt(Math.pow(monster.x - this.x, 2) + Math.pow(monster.y - this.y, 2));
                  if (distance < closestDistance && distance < 300) { // Increased target range
                      closestDistance = distance;
                      closestTarget = monster;
                  }
              });

              if (closestTarget) {
                  const angle = Math.atan2(closestTarget.y - this.y, closestTarget.x - this.x);
                  const bulletSize = 3 + (this.level * 0.2);
                  const bulletRange = 20 + (this.level * 1);
                  const pierceCount = 1 + Math.floor(this.level / 8);

                  // Base attack: Single or Triple Shot
                  if (this.level >= 2) { // Triple Shot
                      this.fireSingleBullet(angle, bulletSize, bulletRange, pierceCount);
                      this.fireSingleBullet(angle - 0.2, bulletSize, bulletRange, pierceCount);
                      this.fireSingleBullet(angle + 0.2, bulletSize, bulletRange, pierceCount);
                  } else { // Single Shot
                      this.fireSingleBullet(angle, bulletSize, bulletRange, pierceCount);
                  }

                  // Additional attacks based on level
                  if (this.level >= 4) { // Homing Missile
                      this.fireHomingMissile(closestTarget, bulletSize, bulletRange, pierceCount);
                  }
                  if (this.level >= 5) { // Chain Lightning
                      this.fireChainLightning(closestTarget, bulletSize, bulletRange, pierceCount);
                  }
              }
              gameState.lastSpacePress = now;
          }

          fireSingleBullet(angle, bulletSize, bulletRange, pierceCount) {
              const bullet = new Bullet(this.x, this.y, angle, this.id, bulletSize, bulletRange);
              bullet.pierce = pierceCount;
              addAndBroadcastProjectile(bullet, 'bullet');
          }

          fireHomingMissile(target, bulletSize, bulletRange, pierceCount) {
              const angle = Math.atan2(target.y - this.y, target.x - this.x);
              const missile = new HomingMissile(this.x, this.y, angle, this.id, target, bulletSize, bulletRange);
              missile.pierce = pierceCount;
              addAndBroadcastProjectile(missile, 'homing_missile');
          }

          fireChainLightning(target, bulletSize, bulletRange, pierceCount) {
              const angle = Math.atan2(target.y - this.y, target.x - this.x);
              const lightning = new ChainLightning(this.x, this.y, angle, this.id, target, bulletSize, bulletRange);
              lightning.pierce = pierceCount;
              addAndBroadcastProjectile(lightning, 'chain_lightning');
          }

          draw() {
              const screenX = this.x - gameState.camera.x + canvas.width / 2;
              const screenY = this.y - gameState.camera.y + canvas.height / 2;

              if (this.invulnerable) {
                  const blinkSpeed = 200;
                  const isVisible = Math.floor(Date.now() / blinkSpeed) % 2 === 0;
                  if (!isVisible) return;
              }

              if (this.stunned) {
                  ctx.save();
                  ctx.translate(screenX, screenY);
                  ctx.rotate(Math.sin(Date.now() * 0.05) * 0.2);
                  ctx.translate(-screenX, -screenY);
              }

              ctx.fillStyle = this.alive ? this.color : '#666666';
              ctx.beginPath();
              ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
              ctx.fill();

              ctx.strokeStyle = this.alive ? '#ffffff' : '#333333';
              ctx.lineWidth = 2;
              ctx.stroke();

              if (this.stunned) {
                  ctx.fillStyle = '#ffff00';
                  ctx.font = '20px Courier New';
                  ctx.textAlign = 'center';
                  ctx.fillText('⭐', screenX, screenY + 5);
                  ctx.restore();
              }

              if (this.invulnerable) {
                  ctx.strokeStyle = '#ffff00';
                  ctx.lineWidth = 3;
                  ctx.setLineDash([5, 5]);
                  ctx.beginPath();
                  ctx.arc(screenX, screenY, this.size + 5, 0, Math.PI * 2);
                  ctx.stroke();
                  ctx.setLineDash([]);
              }

              ctx.fillStyle = '#ffffff';
              ctx.font = '12px Courier New';
              ctx.textAlign = 'center';
              ctx.fillText(this.name, screenX, screenY - 15);

              // 레벨 표시
              if (this.level > 0) {
                  ctx.fillStyle = '#00ff00';
                  ctx.font = '10px Courier New';
                  ctx.fillText(`LV${this.level}`, screenX, screenY + 20);
              }

              if (!this.alive) {
                  ctx.fillStyle = '#ff4444';
                  ctx.font = '16px Courier New';
                  ctx.fillText('💀', screenX, screenY + 5);
              }
          }
      }

      function addAndBroadcastProjectile(projectile, type) {
          projectile.id = type + '_' + Date.now() + '_' + Math.random();
          gameState.bullets.push(projectile);

          if (gameChannel) {
              const message = {
                  type: 'projectile_fired',
                  projectileType: type,
                  id: projectile.id,
                  x: projectile.x,
                  y: projectile.y,
                  angle: projectile.angle,
                  shooterId: projectile.shooterId,
                  bulletSize: projectile.size,
                  bulletRange: projectile.range,
                  createTime: projectile.createTime,
                  timestamp: Date.now()
              };
              if (type === 'homing_missile' || type === 'chain_lightning') {
                  message.targetId = projectile.target.id;
              }
              gameChannel.postMessage(message);
          }
      }

      class Monster {
          constructor(x, y, type) {
              this.x = x;
              this.y = y;
              this.type = type;
              this.alive = true;
              this.stunned = false;
              this.stunStart = 0;
              this.angle = 0;
          }

          update() {
              if (!this.alive) return;

              if (this.stunned && Date.now() - this.stunStart > 2000) {
                  this.stunned = false;
              }

              if (!this.stunned) {
                  this.ai();
              }

              this.angle += 0.1;
          }

          ai() {}

          draw() {
              const screenX = this.x - gameState.camera.x + canvas.width / 2;
              const screenY = this.y - gameState.camera.y + canvas.height / 2;

              if (screenX < -50 || screenX > canvas.width + 50 ||
                  screenY < -50 || screenY > canvas.height + 50) {
                  return;
              }

              if (this.stunned) {
                  ctx.save();
                  ctx.translate(screenX, screenY);
                  ctx.rotate(Math.sin(Date.now() * 0.02) * 0.3);
                  ctx.translate(-screenX, -screenY);
                  ctx.fillStyle = '#666666';
              } else {
                  ctx.fillStyle = this.color;
              }

              this.drawShape(screenX, screenY);

              if (this.stunned) {
                  ctx.fillStyle = '#ffff00';
                  ctx.font = '16px Courier New';
                  ctx.textAlign = 'center';
                  ctx.fillText('💫', screenX, screenY - 20);
                  ctx.restore();
              }
          }
      }

      class Observer extends Monster {
          constructor(x, y) {
              super(x, y, 'observer');
              this.size = 15;
              this.speed = 1.5;
              this.color = '#ff6600';
          }

          ai() {
              let closestPlayer = null;
              let closestDistance = Infinity;

              gameState.players.forEach(player => {
                  if (player.alive && !player.invulnerable) {
                      const distance = Math.sqrt(
                          Math.pow(player.x - this.x, 2) +
                          Math.pow(player.y - this.y, 2)
                      );
                      if (distance < closestDistance) {
                          closestDistance = distance;
                          closestPlayer = player;
                      }
                  }
              });

              if (closestPlayer) {
                  const dx = closestPlayer.x - this.x;
                  const dy = closestPlayer.y - this.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);

                  if (distance > 0) {
                      this.x += (dx / distance) * this.speed;
                      this.y += (dy / distance) * this.speed;
                  }
              }
          }

          drawShape(screenX, screenY) {
              ctx.save();
              ctx.translate(screenX, screenY);
              ctx.rotate(this.angle);

              ctx.beginPath();
              ctx.ellipse(0, 0, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
              ctx.fill();

              ctx.strokeStyle = '#ffaa44';
              ctx.lineWidth = 2;
              ctx.stroke();

              ctx.fillStyle = '#00ffff';
              ctx.beginPath();
              ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
              ctx.fill();

              ctx.strokeStyle = '#00ffff';
              ctx.lineWidth = 1;
              for (let i = 0; i < 8; i++) {
                  const angle = (i / 8) * Math.PI * 2;
                  ctx.beginPath();
                  ctx.moveTo(0, 0);
                  ctx.lineTo(Math.cos(angle) * this.size, Math.sin(angle) * this.size);
                  ctx.stroke();
              }

              ctx.restore();
          }
      }

      class Rusher extends Monster {
          constructor(x, y) {
              super(x, y, 'rusher');
              this.size = 10;
              this.speed = 4;
              this.color = '#ff3333';
              this.rushTarget = null;
              this.rushCooldown = 0;
          }

          ai() {
              const now = Date.now();

              if (now - this.rushCooldown > 3000) {
                  let closestPlayer = null;
                  let closestDistance = Infinity;

                  gameState.players.forEach(player => {
                      if (player.alive) {
                          const distance = Math.sqrt(
                              Math.pow(player.x - this.x, 2) +
                              Math.pow(player.y - this.y, 2)
                          );
                          if (distance < closestDistance && distance < 300) {
                              closestDistance = distance;
                              closestPlayer = player;
                          }
                      }
                  });

                  if (closestPlayer) {
                      this.rushTarget = { x: closestPlayer.x, y: closestPlayer.y };
                      this.rushCooldown = now;
                  }
              }

              if (this.rushTarget) {
                  const dx = this.rushTarget.x - this.x;
                  const dy = this.rushTarget.y - this.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);

                  if (distance > 5) {
                      this.x += (dx / distance) * this.speed;
                      this.y += (dy / distance) * this.speed;
                  } else {
                      this.rushTarget = null;
                  }
              }
          }

          drawShape(screenX, screenY) {
              ctx.beginPath();
              ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
              ctx.fill();

              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              for (let i = 0; i < 6; i++) {
                  const angle = (i / 6) * Math.PI * 2 + this.angle;
                  const startX = screenX + Math.cos(angle) * this.size;
                  const startY = screenY + Math.sin(angle) * this.size;
                  const endX = screenX + Math.cos(angle) * (this.size + 5);
                  const endY = screenY + Math.sin(angle) * (this.size + 5);

                  ctx.beginPath();
                  ctx.moveTo(startX, startY);
                  ctx.lineTo(endX, endY);
                  ctx.stroke();
              }
          }
      }

      class Patroller extends Monster {
          constructor(x, y) {
              super(x, y, 'patroller');
              this.size = 12;
              this.speed = 2;
              this.color = '#9933ff';
              this.patrolTarget = { x: x + Math.random() * 200 - 100, y: y + Math.random() * 200 - 100 };
              this.patrolRadius = 150;
              this.centerX = x;
              this.centerY = y;
          }

          ai() {
              const dx = this.patrolTarget.x - this.x;
              const dy = this.patrolTarget.y - this.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < 20) {
                  const angle = Math.random() * Math.PI * 2;
                  this.patrolTarget = {
                      x: this.centerX + Math.cos(angle) * this.patrolRadius,
                      y: this.centerY + Math.sin(angle) * this.patrolRadius
                  };
              } else {
                  this.x += (dx / distance) * this.speed;
                  this.y += (dy / distance) * this.speed;
              }
          }

          drawShape(screenX, screenY) {
              ctx.save();
              ctx.translate(screenX, screenY);
              ctx.rotate(this.angle);

              ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);

              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.arc(0, 0, 3, 0, Math.PI * 2);
              ctx.fill();

              ctx.restore();
          }
      }

      class Shooter extends Monster {
          constructor(x, y) {
              super(x, y, 'shooter');
              this.size = 14;
              this.color = '#ff33aa';
              this.shootCooldown = 0;
          }

          ai() {
              const now = Date.now();
              if (now - this.shootCooldown > 2000) {
                  let closestPlayer = null;
                  let closestDistance = Infinity;

                  gameState.players.forEach(player => {
                      if (player.alive) {
                          const distance = Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2));
                          if (distance < closestDistance && distance < 400) {
                              closestDistance = distance;
                              closestPlayer = player;
                          }
                      }
                  });

                  if (closestPlayer) {
                      const angle = Math.atan2(closestPlayer.y - this.y, closestPlayer.x - this.x);
                      const bullet = new MonsterBullet(this.x, this.y, angle, this.id);
                      addAndBroadcastProjectile(bullet, 'monster_bullet');
                      this.shootCooldown = now;
                  }
              }
          }

          drawShape(screenX, screenY) {
              ctx.beginPath();
              ctx.rect(screenX - this.size / 2, screenY - this.size / 2, this.size, this.size);
              ctx.fill();
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.stroke();
          }
      }

      class Splitter extends Monster {
          constructor(x, y, size = 16) {
              super(x, y, 'splitter');
              this.size = size;
              this.color = '#33ff33';
              this.speed = 1;
          }

          ai() {
              // Simple AI: move towards the center of the map
              const dx = gameState.mapSize.width / 2 - this.x;
              const dy = gameState.mapSize.height / 2 - this.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance > 0) {
                  this.x += (dx / distance) * this.speed;
                  this.y += (dy / distance) * this.speed;
              }
          }

          drawShape(screenX, screenY) {
              ctx.beginPath();
              ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.stroke();
          }

          onDeath() {
              if (this.size > 8) {
                  for (let i = 0; i < 2; i++) {
                      const newSplitter = new Splitter(this.x + Math.random() * 10 - 5, this.y + Math.random() * 10 - 5, this.size / 2);
                      newSplitter.id = 'monster_' + Date.now() + '_' + Math.random();
                      gameState.monsters.push(newSplitter);
                  }
              }
          }
      }

      class Bullet {
          constructor(x, y, angle, shooterId, bulletSize = 3, bulletRange = 20) {
              this.x = x;
              this.y = y;
              this.angle = angle;
              this.speed = 8;
              this.shooterId = shooterId;
              this.size = bulletSize;
              this.range = bulletRange; // 충돌 판정 범위
              this.life = 1000;
              this.createTime = Date.now();
              this.trailPoints = []; // 궤적 효과
              this.pierce = 1;
          }

          update() {
              // 궤적 추가
              this.trailPoints.push({ x: this.x, y: this.y });
              if (this.trailPoints.length > 5) {
                  this.trailPoints.shift();
              }

              this.x += Math.cos(this.angle) * this.speed;
              this.y += Math.sin(this.angle) * this.speed;

              if (Date.now() - this.createTime > this.life) {
                  return false;
              }

              return true;
          }

          draw() {
              const screenX = this.x - gameState.camera.x + canvas.width / 2;
              const screenY = this.y - gameState.camera.y + canvas.height / 2;

              // 궤적 그리기
              ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
              ctx.lineWidth = this.size * 0.5;
              ctx.beginPath();
              for (let i = 0; i < this.trailPoints.length; i++) {
                  const point = this.trailPoints[i];
                  const trailScreenX = point.x - gameState.camera.x + canvas.width / 2;
                  const trailScreenY = point.y - gameState.camera.y + canvas.height / 2;

                  if (i === 0) {
                      ctx.moveTo(trailScreenX, trailScreenY);
                  } else {
                      ctx.lineTo(trailScreenX, trailScreenY);
                  }
              }
              ctx.stroke();

              // 총알 본체 (크기에 따라 색상 변화)
              const intensity = Math.min(this.size / 6, 1); // 최대 6일 때 최고 밝기
              ctx.fillStyle = `rgb(${255}, ${255}, ${Math.floor(255 * intensity)})`;
              ctx.beginPath();
              ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
              ctx.fill();

              // 광채 효과 (레벨이 높을수록 강함)
              if (this.size > 3) {
                  ctx.fillStyle = `rgba(255, 255, 0, ${0.3 * intensity})`;
                  ctx.beginPath();
                  ctx.arc(screenX, screenY, this.size * 1.5, 0, Math.PI * 2);
                  ctx.fill();
              }

              // 꼬리 효과
              ctx.strokeStyle = `rgba(255, 255, 255, ${intensity})`;
              ctx.lineWidth = this.size * 0.3;
              ctx.beginPath();
              ctx.moveTo(screenX, screenY);
              ctx.lineTo(
                  screenX - Math.cos(this.angle) * (10 + this.size),
                  screenY - Math.sin(this.angle) * (10 + this.size)
              );
              ctx.stroke();
          }
      }

      class HomingMissile extends Bullet {
          constructor(x, y, angle, shooterId, target, bulletSize, bulletRange) {
              super(x, y, angle, shooterId, bulletSize, bulletRange);
              this.target = target;
              this.speed = 4;
              this.turnSpeed = 0.1;
              this.pierce = 1;
          }

          update() {
              if (this.target && this.target.alive) {
                  const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                  let angleDiff = targetAngle - this.angle;
                  while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                  while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                  this.angle += Math.max(-this.turnSpeed, Math.min(this.turnSpeed, angleDiff));
              }

              return super.update();
          }
      }

      class ChainLightning extends Bullet {
          constructor(x, y, angle, shooterId, target, bulletSize, bulletRange) {
              super(x, y, angle, shooterId, bulletSize, bulletRange);
              this.target = target;
              this.jumps = 3;
              this.jumpedTo = new Set([target.id]);
              this.pierce = 1;
          }

          onHit(hitTarget) {
              if (this.jumps > 0) {
                  this.jumps--;
                  let closestTarget = null;
                  let closestDistance = Infinity;

                  const findNextTarget = (entities) => {
                      entities.forEach(entity => {
                          if (entity.alive && !this.jumpedTo.has(entity.id)) {
                              const distance = Math.sqrt(Math.pow(entity.x - this.x, 2) + Math.pow(entity.y - this.y, 2));
                              if (distance < closestDistance && distance < 200) {
                                  closestDistance = distance;
                                  closestTarget = entity;
                              }
                          }
                      });
                  };

                  findNextTarget(gameState.monsters);
                  findNextTarget(gameState.players);

                  if (closestTarget) {
                      this.target = closestTarget;
                      this.jumpedTo.add(closestTarget.id);
                      this.x = hitTarget.x;
                      this.y = hitTarget.y;
                      this.createTime = Date.now(); // Reset life
                      return true; // Still alive
                  }
              }
              return false; // No more jumps, bullet dies
          }
      }

      class MonsterBullet extends Bullet {
          constructor(x, y, angle, shooterId) {
              super(x, y, angle, shooterId, 4, 10);
              this.speed = 2;
              this.color = '#ff33aa';
          }

          draw() {
              const screenX = this.x - gameState.camera.x + canvas.width / 2;
              const screenY = this.y - gameState.camera.y + canvas.height / 2;

              ctx.fillStyle = this.color;
              ctx.beginPath();
              ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
              ctx.fill();
          }
      }

      function initRealtimeSync() {
          try {
              gameChannel = new BroadcastChannel('game_' + gameState.roomId);

              gameChannel.onmessage = (event) => {
                  handleGameMessage(event.data);
              };

              console.log('BroadcastChannel 연결 성공');

              // 60fps 동기화 (16ms)
              setInterval(broadcastMyPlayer, 16);
              setInterval(broadcastGameWorld, 16);

          } catch (error) {
              console.log('BroadcastChannel 미지원, localStorage로 폴백');
              initLocalStorageSync();
          }
      }

      function handleGameMessage(data) {
          switch(data.type) {
              case 'player_update':
                  if (data.playerId !== gameState.myPlayerId) {
                      updateOtherPlayer(data);
                  }
                  break;

              case 'world_update':
                  if (!gameState.isHost) {
                      updateGameWorld(data);
                  }
                  break;

              case 'projectile_fired':
                  if (data.shooterId !== gameState.myPlayerId) {
                      addProjectile(data);
                  }
                  break;

              case 'player_joined':
                  console.log('새 플레이어 참가:', data.playerName);
                  break;

              case 'player_respawn':
                  if (gameState.isHost) {
                      const player = gameState.players.get(data.playerId);
                      if (player) {
                          player.alive = true;
                          player.invulnerable = true;
                          player.invulnerabilityStart = Date.now();
                          console.log(`${player.name}이(가) 부활했습니다.`);
                      }
                  }
                  break;

              case 'new_host_elected':
                  clearTimeout(electionTimeout);
                  gameState.hostId = data.hostId;
                  gameState.isHost = (gameState.myPlayerId === data.hostId);
                  if (gameState.isHost) {
                      console.log('내가 새로운 호스트로 선출되었습니다.');
                      document.getElementById('levelControl').style.display = 'block';
                  } else {
                      const hostPlayer = gameState.players.get(data.hostId);
                      console.log(`새로운 호스트: ${hostPlayer ? hostPlayer.name : '알 수 없음'}`);
                      document.getElementById('levelControl').style.display = 'none';
                  }
                  break;

              case 'level_change':
                  gameState.gameLevel = data.level;
                  document.getElementById('levelDisplay').textContent = gameState.gameLevel;
                  break;

              case 'game_reset':
                  gameState.monsters = [];
                  gameState.bullets = [];
                  document.getElementById('resetContainer').style.display = 'none';
                  break;

              case 'request_host_sync':
                  if (gameState.isHost) {
                      gameChannel.postMessage({ type: 'new_host_elected', hostId: gameState.hostId });
                  }
                  break;

              case 'host_ping':
                  // I am the host, and someone is pinging me. I should respond.
                  if (gameState.isHost) {
                      gameChannel.postMessage({ type: 'host_pong', hostId: gameState.hostId });
                  }
                  break;

              case 'host_pong':
                  // A host has responded to a ping. Update the host ID.
                  gameState.hostId = data.hostId;
                  break;
          }
      }

      function broadcastMyPlayer() {
          if (!gameChannel || Date.now() - lastBroadcast < 12) return; // 12ms 쓰로틀링

          const myPlayer = gameState.players.get(gameState.myPlayerId);
          if (!myPlayer) return;

          gameChannel.postMessage({
              type: 'player_update',
              playerId: myPlayer.id,
              playerName: myPlayer.name,
              x: myPlayer.x,
              y: myPlayer.y,
              color: myPlayer.color,
              alive: myPlayer.alive,
              score: myPlayer.score,
              bullets: myPlayer.bulletLevel,
              invulnerable: myPlayer.invulnerable,
              stunned: myPlayer.stunned,
              timestamp: Date.now()
          });

          lastBroadcast = Date.now();
      }

      function updateOtherPlayer(data) {
          // 방어 코드: 자기 자신의 정보는 업데이트하지 않음
          if (data.playerId === gameState.myPlayerId) {
              console.warn('updateOtherPlayer was called with my own ID. Ignoring.');
              return;
          }

          if (!gameState.players.has(data.playerId)) {
              const newPlayer = new Player(
                  data.playerId,
                  data.playerName,
                  data.x,
                  data.y,
                  data.color
              );
              gameState.players.set(data.playerId, newPlayer);
          } else {
              const player = gameState.players.get(data.playerId);
              player.x = data.x;
              player.y = data.y;
              player.alive = data.alive;
              player.score = data.score;
              player.bullets = data.bullets;
              player.invulnerable = data.invulnerable;
              player.stunned = data.stunned;
          }
      }

      function broadcastGameWorld() {
          if (!gameChannel || !gameState.isHost) return;

          gameChannel.postMessage({
              type: 'world_update',
              hostId: gameState.hostId, // 현재 호스트 ID 전파
              players: Array.from(gameState.players.values()), // 모든 플레이어 상태 추가
              monsters: gameState.monsters.map(m => ({
                  id: m.id,
                  type: m.type,
                  x: m.x,
                  y: m.y,
                  alive: m.alive,
                  stunned: m.stunned,
                  stunStart: m.stunStart,
                  angle: m.angle
              })),
              bullets: gameState.bullets.map(b => ({
                  id: b.id,
                  x: b.x,
                  y: b.y,
                  angle: b.angle,
                  shooterId: b.shooterId,
                  createTime: b.createTime
              })),
              gameStartTime: gameState.gameStartTime,
              timestamp: Date.now()
          });
      }

      function updateWorldState(worldData) {
          if (worldData.hostId) {
              gameState.hostId = worldData.hostId;
          }

          // 호스트가 보낸 플레이어 목록으로 로컬 상태를 업데이트
          if (worldData.players) {
              const receivedPlayerIds = new Set();
              worldData.players.forEach(playerData => {
                  receivedPlayerIds.add(playerData.id);

                  if (playerData.id === gameState.myPlayerId) {
                      // 내 플레이어 정보 업데이트 (위치는 제외)
                      const myPlayer = gameState.players.get(gameState.myPlayerId);
                      if (myPlayer) {
                          // 호스트가 내가 죽었다고 하면, 게임오버 처리
                          if (myPlayer.alive && !playerData.alive) {
                              showGameOver();
                          }
                          myPlayer.alive = playerData.alive;
                          myPlayer.score = playerData.score;
                          myPlayer.stunned = playerData.stunned;
                          myPlayer.invulnerable = playerData.invulnerable;
                          myPlayer.bulletLevel = playerData.bulletLevel;
                      }
                  } else {
                      // 다른 플레이어 정보 업데이트
                      if (!gameState.players.has(playerData.id)) {
                          // 새로운 플레이어 추가
                          const newPlayer = new Player(playerData.id, playerData.name, playerData.x, playerData.y, playerData.color);
                          gameState.players.set(playerData.id, newPlayer);
                      }
                      const player = gameState.players.get(playerData.id);
                      if (player) {
                          player.x = playerData.x;
                          player.y = playerData.y;
                          player.alive = playerData.alive;
                          player.score = playerData.score;
                          player.stunned = playerData.stunned;
                          player.invulnerable = playerData.invulnerable;
                          player.bulletLevel = playerData.bulletLevel;
                      }
                  }
              });

              // 호스트가 보낸 목록에 없는데 로컬에 있는 플레이어는 삭제 (연결 끊김)
              gameState.players.forEach(player => {
                  if (player.id === gameState.myPlayerId) return; // 자기 자신은 삭제하지 않음
                  if (!receivedPlayerIds.has(player.id)) {
                      gameState.players.delete(player.id);
                  }
              });
          }

          // 몬스터와 총알 정보는 기존과 동일하게 업데이트
          gameState.monsters = worldData.monsters.map(monsterData => {
              let monster;
              switch(monsterData.type) {
                  case 'observer':
                      monster = new Observer(monsterData.x, monsterData.y);
                      break;
                  case 'rusher':
                      monster = new Rusher(monsterData.x, monsterData.y);
                      break;
                  case 'patroller':
                      monster = new Patroller(monsterData.x, monsterData.y);
                      break;
                  default:
                      monster = new Observer(monsterData.x, monsterData.y);
              }
              monster.id = monsterData.id;
              monster.x = monsterData.x;
              monster.y = monsterData.y;
              monster.alive = monsterData.alive;
              monster.stunned = monsterData.stunned;
              monster.stunStart = monsterData.stunStart;
              monster.angle = monsterData.angle;
              return monster;
          });

          gameState.bullets = worldData.bullets.map(bulletData => {
              const bullet = new Bullet(bulletData.x, bulletData.y, bulletData.angle, bulletData.shooterId);
              bullet.id = bulletData.id;
              bullet.createTime = bulletData.createTime;
              return bullet;
          });

          if (worldData.gameStartTime && !gameState.gameStartTime) {
              gameState.gameStartTime = worldData.gameStartTime;
          }
      }

      function updateGameWorld(data) {
          updateWorldState(data);
      }

      function addProjectile(data) {
          let projectile;
          let target = null;

          if (data.targetId) {
              target = gameState.players.get(data.targetId) || gameState.monsters.find(m => m.id === data.targetId);
          }

          switch (data.projectileType) {
              case 'homing_missile':
                  projectile = new HomingMissile(data.x, data.y, data.angle, data.shooterId, target, data.bulletSize, data.bulletRange);
                  break;
              case 'chain_lightning':
                  projectile = new ChainLightning(data.x, data.y, data.angle, data.shooterId, target, data.bulletSize, data.bulletRange);
                  break;
              case 'monster_bullet':
                  projectile = new MonsterBullet(data.x, data.y, data.angle, data.shooterId);
                  break;
              default: // bullet
                  projectile = new Bullet(data.x, data.y, data.angle, data.shooterId, data.bulletSize, data.bulletRange);
                  break;
          }

          projectile.id = data.id;
          projectile.createTime = data.createTime;
          gameState.bullets.push(projectile);
      }

      function changeLevel(amount) {
          if (!gameState.isHost) return;

          const newLevel = gameState.gameLevel + amount;
          if (newLevel >= 1 && newLevel <= 10) {
              gameState.gameLevel = newLevel;
              document.getElementById('levelDisplay').textContent = gameState.gameLevel;

              if (gameChannel) {
                  gameChannel.postMessage({ type: 'level_change', level: gameState.gameLevel });
              } else {
                  localStorage.setItem('gameEvent_level_change', JSON.stringify({ level: gameState.gameLevel, timestamp: Date.now() }));
              }
          }
      }

      function spawnMonster() {
          const now = Date.now();
          const spawnInterval = 1000 / gameState.gameLevel;

          if (now - gameState.lastMonsterSpawn > spawnInterval) {
              const players = Array.from(gameState.players.values());
              if (players.length === 0) return;

              const livingPlayers = players.filter(p => p.alive);
              if (livingPlayers.length === 0) return;

              const averageLevel = players.reduce((sum, p) => sum + p.level, 0) / players.length;

              let spawnTargetPlayer = livingPlayers[Math.floor(Math.random() * livingPlayers.length)];

              const spawnDistance = 300 + Math.random() * 200;
              const angle = Math.random() * Math.PI * 2;
              const x = spawnTargetPlayer.x + Math.cos(angle) * spawnDistance;
              const y = spawnTargetPlayer.y + Math.sin(angle) * spawnDistance;

              let monsterTypes = [Observer, Rusher];
              let weights = [0.5, 0.5];

              if (averageLevel >= 5) {
                  monsterTypes.push(Shooter);
                  weights = [0.4, 0.4, 0.2];
              }
              if (averageLevel >= 10) {
                  monsterTypes.push(Splitter);
                  weights = [0.3, 0.3, 0.2, 0.2];
              }

              let random = Math.random();
              let MonsterClass = monsterTypes[0];

              for (let j = 0; j < weights.length; j++) {
                  if (random < weights[j]) {
                      MonsterClass = monsterTypes[j];
                      break;
                  }
                  random -= weights[j];
              }

              const monster = new MonsterClass(x, y);
              monster.id = 'monster_' + Date.now() + '_' + Math.random();
              gameState.monsters.push(monster);

              gameState.lastMonsterSpawn = now;
          }
      }

      function checkCollisions() {
          gameState.players.forEach(player => {
              if (!player.alive || player.invulnerable) return;

              gameState.monsters.forEach(monster => {
                  if (!monster.alive) return;

                  const distance = Math.sqrt(
                      Math.pow(player.x - monster.x, 2) +
                      Math.pow(player.y - monster.y, 2)
                  );

                  if (distance < player.size + monster.size - 2) { // 2px 정도의 여유를 줌
                      player.alive = false;

                      if (player.id === gameState.myPlayerId) {
                          showGameOver();
                      }
                  }
              });
          });

          const playerArray = Array.from(gameState.players.values());
          for (let i = 0; i < playerArray.length; i++) {
              for (let j = i + 1; j < playerArray.length; j++) {
                  const p1 = playerArray[i];
                  const p2 = playerArray[j];

                  if (!p1.alive || !p2.alive) continue;

                  const distance = Math.sqrt(
                      Math.pow(p1.x - p2.x, 2) +
                      Math.pow(p1.y - p2.y, 2)
                  );

                  if (distance < p1.size + p2.size) {
                      p1.stunned = true;
                      p1.stunStart = Date.now();
                      p2.stunned = true;
                      p2.stunStart = Date.now();

                      const pushForce = 20;
                      const dx = p2.x - p1.x;
                      const dy = p2.y - p1.y;
                      const dist = Math.sqrt(dx * dx + dy * dy);

                      if (dist > 0) {
                          p1.x -= (dx / dist) * pushForce;
                          p1.y -= (dy / dist) * pushForce;
                          p2.x += (dx / dist) * pushForce;
                          p2.y += (dy / dist) * pushForce;
                      }
                  }
              }
          }

          gameState.bullets.forEach((bullet, bulletIndex) => {
              if (bullet instanceof MonsterBullet) {
                  gameState.players.forEach(player => {
                      if (!player.alive || player.invulnerable) return;

                      const distance = Math.sqrt(Math.pow(player.x - bullet.x, 2) + Math.pow(player.y - bullet.y, 2));

                      if (distance < player.size + bullet.size) {
                          player.alive = false;
                          gameState.bullets.splice(bulletIndex, 1);

                          if (player.id === gameState.myPlayerId) {
                              showGameOver();
                          }
                      }
                  });
              } else {
                  gameState.players.forEach(player => {
                      if (player.id === bullet.shooterId || !player.alive) return;

                      const distance = Math.sqrt(
                          Math.pow(player.x - bullet.x, 2) +
                          Math.pow(player.y - bullet.y, 2)
                      );

                      // 총알 레벨에 따른 충돌 범위 사용
                      if (distance < player.size + bullet.range) {
                          player.stunned = true;
                          player.stunStart = Date.now();
                          gameState.bullets.splice(bulletIndex, 1);
                      }
                  });

                  gameState.monsters.forEach(monster => {
                      if (!monster.alive) return;

                      const distance = Math.sqrt(
                          Math.pow(monster.x - bullet.x, 2) +
                          Math.pow(monster.y - bullet.y, 2)
                      );

                      if (distance < monster.size + bullet.range) {
                          bullet.pierce--;
                          if (bullet.pierce <= 0) {
                              if (bullet instanceof ChainLightning) {
                                  if (!bullet.onHit(monster)) {
                                      gameState.bullets.splice(bulletIndex, 1);
                                  }
                              } else {
                                  gameState.bullets.splice(bulletIndex, 1);
                              }
                          }

                          if (monster instanceof Splitter) {
                              monster.onDeath();
                          }
                          monster.alive = false;
                          const shooter = gameState.players.get(bullet.shooterId);
                          if (shooter) {
                              shooter.killScore += 10; // 몬스터를 잡으면 10점 추가
                          }
                      }
                  });
              }
          });
      }

      function showGameOver() {
          const myPlayer = gameState.players.get(gameState.myPlayerId);
          document.getElementById('finalScore').textContent =
              `최종 점수: ${myPlayer.score}점 (생존 시간: ${Math.floor(myPlayer.score / 10)}초)`;
          document.getElementById('gameOver').style.display = 'flex';
      }

      function respawn() {
          const myPlayer = gameState.players.get(gameState.myPlayerId);
          myPlayer.alive = true;
          myPlayer.invulnerable = true;
          myPlayer.invulnerabilityStart = Date.now();

          let safeX, safeY;
          let attempts = 0;
          const maxAttempts = 50;
          const respawnRadius = 400;

          do {
              const angle = Math.random() * Math.PI * 2;
              const radius = Math.random() * respawnRadius;
              safeX = myPlayer.x + Math.cos(angle) * radius;
              safeY = myPlayer.y + Math.sin(angle) * radius;
              attempts++;
          } while (attempts < maxAttempts && isTooCloseToMonsters(safeX, safeY));

          if (attempts >= maxAttempts) {
              console.warn("안전한 리스폰 지역을 찾지 못했습니다. 플레이어의 마지막 위치에서 리스폰합니다.");
              safeX = myPlayer.x;
              safeY = myPlayer.y;
          }

          myPlayer.x = safeX;
          myPlayer.y = safeY;

          document.getElementById('gameOver').style.display = 'none';
          gameState.gameStartTime = Date.now();

          if (gameChannel) {
              gameChannel.postMessage({ type: 'player_respawn', playerId: myPlayer.id });
          } else {
              // localStorage 폴백을 위한 이벤트 기록
              const eventKey = 'event_respawn_' + gameState.myPlayerId + '_' + Date.now();
              localStorage.setItem(eventKey, JSON.stringify({ playerId: gameState.myPlayerId }));
          }
      }

      function isTooCloseToMonsters(x, y) {
          return gameState.monsters.some(monster => {
              const distance = Math.sqrt(
                  Math.pow(x - monster.x, 2) +
                  Math.pow(y - monster.y, 2)
              );
              return distance < 100;
          });
      }

      function resetGame() {
          if (!gameState.isHost) return;

          gameState.monsters = [];
          gameState.bullets = [];

          if (gameChannel) {
              gameChannel.postMessage({ type: 'game_reset' });
          } else {
              localStorage.setItem('gameEvent_reset', JSON.stringify({ timestamp: Date.now() }));
          }

          document.getElementById('resetContainer').style.display = 'none';
      }

      function updatePlayerList() {
          const playersDiv = document.getElementById('players');
          playersDiv.innerHTML = '';

          const sortedPlayers = Array.from(gameState.players.values())
              .sort((a, b) => b.score - a.score);

          sortedPlayers.forEach((player, index) => {
              const playerDiv = document.createElement('div');
              playerDiv.style.color = player.color;
              playerDiv.style.margin = '2px 0';
              playerDiv.innerHTML = `
                  ${index + 1}. ${player.name}
                  ${player.alive ? '🟢' : '💀'}
                  (${player.score}점)
              `;
              playersDiv.appendChild(playerDiv);
          });
      }

      function updateUI() {
          if (!gameState.gameRunning) return;

          const timeSurvived = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
          document.getElementById('timeDisplay').textContent = timeSurvived;
          document.getElementById('observerCount').textContent = gameState.monsters.length;

          const myPlayer = gameState.players.get(gameState.myPlayerId);
          if (myPlayer) {
              document.getElementById('myScore').textContent = myPlayer.score;
          }
      }

      function updateCamera() {
          const myPlayer = gameState.players.get(gameState.myPlayerId);
          if (myPlayer && myPlayer.alive) {
              const lerp = 0.1;
              gameState.camera.x += (myPlayer.x - gameState.camera.x) * lerp;
              gameState.camera.y += (myPlayer.y - gameState.camera.y) * lerp;
          }
      }

      function gameLoop() {
          // 호스트는 모든 게임 로직(스폰, 업데이트, 충돌)에 대한 권한을 가짐
          if (gameState.isHost) {
              const allPlayersDead = Array.from(gameState.players.values()).every(p => !p.alive);
              if (allPlayersDead && gameState.players.size > 0) {
                  document.getElementById('resetContainer').style.display = 'block';
              } else {
                  document.getElementById('resetContainer').style.display = 'none';
              }

              spawnMonster();
              gameState.monsters.forEach(monster => monster.update());
              gameState.bullets = gameState.bullets.filter(bullet => bullet.update());
              checkCollisions(); // 모든 충돌 계산은 호스트만 수행

              // 시야에서 너무 멀리 떨어진 몬스터와 총알 정리
              const cleanupThreshold = 2000; // 맵 시야 범위
              const players = Array.from(gameState.players.values());
              if (players.length > 0) {
                  gameState.monsters = gameState.monsters.filter(monster => {
                      return monster.alive && players.some(p => Math.sqrt(Math.pow(monster.x - p.x, 2) + Math.pow(monster.y - p.y, 2)) < cleanupThreshold);
                  });
                  gameState.bullets = gameState.bullets.filter(bullet => {
                      return players.some(p => Math.sqrt(Math.pow(bullet.x - p.x, 2) + Math.pow(bullet.y - p.y, 2)) < cleanupThreshold);
                  });
              }
          }

          // 모든 플레이어는 자신의 입력을 처리 (클라이언트 측 예측)
          const myPlayer = gameState.players.get(gameState.myPlayerId);
          if (myPlayer && myPlayer.alive) {
              myPlayer.update();
          }

          // 렌더링은 항상 수행 (관전 모드를 위해)
          ctx.fillStyle = '#000428';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          for (let i = 0; i < 100; i++) {
              const starX = (Math.sin(i * 12.9898) * 43758.5453) % gameState.mapSize.width;
              const starY = (Math.cos(i * 78.233) * 43758.5453) % gameState.mapSize.height;
              const screenX = starX - gameState.camera.x + canvas.width / 2;
              const screenY = starY - gameState.camera.y + canvas.height / 2;

              if (screenX >= 0 && screenX <= canvas.width &&
                  screenY >= 0 && screenY <= canvas.height) {
                  ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(i) * 0.2})`;
                  ctx.fillRect(screenX, screenY, 1, 1);
              }
          }

          updateCamera();

          gameState.monsters.forEach(monster => monster.draw());
          gameState.bullets.forEach(bullet => bullet.draw());
          gameState.players.forEach(player => player.draw());

          updateUI();
          updatePlayerList();

          requestAnimationFrame(gameLoop);
      }

      function joinGame() {
          if (gameState.debug) console.log('Player joining game');
          if (gameState.debug) console.log('Player joining game');
          const nameInput = document.getElementById('playerName');
          const name = nameInput.value.trim();

          if (!name) {
              alert('닉네임을 입력하세요!');
              return;
          }

          const urlParams = new URLSearchParams(window.location.search);
          let roomId = urlParams.get('room');

          if (!roomId) {
              roomId = 'room_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
              gameState.isHost = true;

              try {
                  const newUrl = window.location.protocol + '//' + window.location.host + window.location.pathname + '?room=' + roomId;
                  window.history.pushState({path: newUrl}, '', newUrl);
                  showRoomLink(newUrl);
              } catch (error) {
                  const simulatedUrl = 'https://yourusername.github.io/your-game?room=' + roomId;
                  showRoomLink(simulatedUrl);
                  console.log('실제 배포 시 사용할 방 ID:', roomId);
              }
          }

          gameState.roomId = roomId;

          const statusElement = document.getElementById('connectionStatus');
          if (statusElement) {
              statusElement.textContent = gameState.isHost ? '방장 (호스트)' : '참가자';
              statusElement.style.color = gameState.isHost ? '#ffaa00' : '#00ff00';
          }

          if (gameState.isHost) {
              document.getElementById('levelControl').style.display = 'block';
          }

          document.getElementById('joinForm').style.display = 'none';
          document.getElementById('gameCanvas').style.display = 'block';
          document.getElementById('gameUI').style.display = 'block';
          document.getElementById('playerList').style.display = 'block';
          document.getElementById('instructions').style.display = 'block';

          const playerId = 'player_' + Date.now() + '_' + Math.random();
          if (gameState.isHost) {
              gameState.hostId = playerId;
          }
          const playerColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
          const startX = 400;
          const startY = 400;

          const player = new Player(playerId, name, startX, startY, playerColor);
          gameState.players.set(playerId, player);
          gameState.myPlayerId = playerId;
          gameState.gameRunning = true;
          gameState.gameStartTime = Date.now();

          initRealtimeSync();

          if (!gameState.isHost) {
              checkForHost();
          }

          setTimeout(() => {
              if (gameChannel) {
                  gameChannel.postMessage({
                      type: 'player_joined',
                      playerId: playerId,
                      playerName: name,
                      timestamp: Date.now()
                  });
              }
          }, 100);

          gameLoop();
      }

      function showRoomLink(url) {
          const linkDiv = document.createElement('div');
          linkDiv.style.position = 'fixed';
          linkDiv.style.top = '10px';
          linkDiv.style.left = '50%';
          linkDiv.style.transform = 'translateX(-50%)';
          linkDiv.style.background = 'rgba(0, 0, 0, 0.9)';
          linkDiv.style.color = '#00ff00';
          linkDiv.style.padding = '10px';
          linkDiv.style.borderRadius = '5px';
          linkDiv.style.border = '1px solid #00ff41';
          linkDiv.style.zIndex = '100';
          linkDiv.style.textAlign = 'center';
          linkDiv.innerHTML = `
              <div>친구들과 함께 플레이하려면 이 링크를 공유하세요:</div>
              <input type="text" value="${url}" readonly style="width: 400px; margin: 5px; padding: 5px; background: #000; color: #00ff00; border: 1px solid #00ff41;">
              <button onclick="copyToClipboard('${url}')" style="margin: 5px; padding: 5px 10px; background: #004e92; color: #00ff00; border: 1px solid #00ff41; cursor: pointer;">복사</button>
              <button onclick="this.parentElement.remove()" style="margin: 5px; padding: 5px 10px; background: #004e92; color: #00ff00; border: 1px solid #00ff41; cursor: pointer;">닫기</button>
              <div style="font-size: 10px; margin-top: 10px; color: #888;">
                  💡 현재 Claude 환경에서는 URL 링크가 제한됩니다.<br>
                  GitHub.io에 배포하면 실제 링크로 친구 초대가 가능합니다!<br>
                  지금은 같은 브라우저에서 새 탭을 열어서 테스트해보세요.<br>
                  🚀 BroadcastChannel API로 실시간 동기화됩니다!
              </div>
          `;
          document.body.appendChild(linkDiv);
      }

      function copyToClipboard(text) {
          try {
              navigator.clipboard.writeText(text).then(() => {
                  alert('링크가 복사되었습니다!');
              }).catch(() => {
                  const textArea = document.createElement('textarea');
                  textArea.value = text;
                  document.body.appendChild(textArea);
                  textArea.select();
                  document.execCommand('copy');
                  document.body.removeChild(textArea);
                  alert('링크가 복사되었습니다!');
              });
          } catch (error) {
              alert('링크를 수동으로 복사해주세요: ' + text);
          }
      }

      function initLocalStorageSync() {
          console.log('localStorage 동기화 사용 (저속)');

          // 1. 자신의 플레이어 정보를 20fps로 저장
          setInterval(() => {
              const myPlayer = gameState.players.get(gameState.myPlayerId);
              if (myPlayer) {
                  localStorage.setItem('player_' + gameState.myPlayerId, JSON.stringify({
                      id: myPlayer.id,
                      name: myPlayer.name,
                      x: myPlayer.x,
                      y: myPlayer.y,
                      color: myPlayer.color,
                      alive: myPlayer.alive,
                      score: myPlayer.score,
                      bullets: myPlayer.bullets,
                      invulnerable: myPlayer.invulnerable,
                      stunned: myPlayer.stunned,
                      timestamp: Date.now()
                  }));
              }
          }, 50);

          // 2. 호스트는 게임 월드 정보를 10fps로 저장
          setInterval(() => {
              if (gameState.isHost) {
                  localStorage.setItem('gameWorld_' + gameState.roomId, JSON.stringify({
                      players: Array.from(gameState.players.values()),
                      monsters: gameState.monsters.map(m => ({
                          id: m.id,
                          type: m.type,
                          x: m.x,
                          y: m.y,
                          alive: m.alive,
                          stunned: m.stunned,
                          stunStart: m.stunStart,
                          angle: m.angle
                      })),
                      bullets: gameState.bullets.map(b => ({
                          id: b.id,
                          x: b.x,
                          y: b.y,
                          angle: b.angle,
                          shooterId: b.shooterId,
                          bulletSize: b.size,
                          bulletRange: b.range,
                          createTime: b.createTime
                      })),
                      gameStartTime: gameState.gameStartTime,
                      hostId: gameState.hostId,
                      timestamp: Date.now()
                  }));
              }
          }, 100);

          // 3. 다른 플레이어 정보와 월드 정보를 20fps로 확인
          setInterval(() => {
              if (gameState.isHost) {
                  // 리스폰 이벤트 확인 (localStorage 폴백용)
                  const storageKeys = Object.keys(localStorage);
                  const respawnEvents = storageKeys.filter(key => key.startsWith('event_respawn_'));
                  respawnEvents.forEach(key => {
                      try {
                          const eventData = JSON.parse(localStorage.getItem(key));
                          const player = gameState.players.get(eventData.playerId);
                          if (player) {
                              player.alive = true;
                              player.invulnerable = true;
                              player.invulnerabilityStart = Date.now();
                              console.log(`${player.name}이(가) 부활했습니다. (localStorage)`);
                          }
                      } catch(e) { console.error('localStorage 이벤트 처리 오류:', e); }
                      localStorage.removeItem(key); // 처리된 이벤트는 삭제
                  });
              }

              checkOtherPlayersInStorage();
              if (!gameState.isHost) {
                  checkGameWorldInStorage();
              }
          }, 50);
      }

      function checkOtherPlayersInStorage() {
          const storageKeys = Object.keys(localStorage);
          const myPlayerKey = 'player_' + gameState.myPlayerId;
          const playerKeys = storageKeys.filter(key => key.startsWith('player_') && key !== myPlayerKey);

          playerKeys.forEach(key => {
              try {
                  const playerData = JSON.parse(localStorage.getItem(key));
                  const timeDiff = Date.now() - playerData.timestamp;

                  if (timeDiff < 5000) {
                      if (!gameState.players.has(playerData.id)) {
                          const newPlayer = new Player(
                              playerData.id,
                              playerData.name,
                              playerData.x,
                              playerData.y,
                              playerData.color
                          );
                          newPlayer.alive = playerData.alive;
                          newPlayer.score = playerData.score;
                          newPlayer.bullets = playerData.bullets;
                          newPlayer.invulnerable = playerData.invulnerable;
                          newPlayer.stunned = playerData.stunned;
                          gameState.players.set(playerData.id, newPlayer);
                          console.log('새 플레이어 발견:', playerData.name);
                      } else {
                          const existingPlayer = gameState.players.get(playerData.id);
                          existingPlayer.x = playerData.x;
                          existingPlayer.y = playerData.y;
                          existingPlayer.alive = playerData.alive;
                          existingPlayer.score = playerData.score;
                          existingPlayer.bullets = playerData.bullets;
                          existingPlayer.invulnerable = playerData.invulnerable;
                          existingPlayer.stunned = playerData.stunned;
                      }
                  } else {
                      if (gameState.players.has(playerData.id)) {
                          console.log('플레이어 연결 끊김:', gameState.players.get(playerData.id).name);

                          // 호스트가 나갔는지 확인
                          if (playerData.id === gameState.hostId) {
                              console.log('호스트 연결이 끊겼습니다. 새로운 호스트를 선출합니다.');
                              gameState.hostId = null; // 호스트 정보 초기화
                              electNewHost();
                          }

                          gameState.players.delete(playerData.id);
                          localStorage.removeItem(key);
                      }
                  }
              } catch (error) {
                  console.error('플레이어 데이터 파싱 오류:', error);
                  localStorage.removeItem(key);
              }
          });
      }

      function checkGameWorldInStorage() {
          try {
              const worldData = localStorage.getItem('gameWorld_' + gameState.roomId);
              if (worldData) {
                  const gameWorld = JSON.parse(worldData);
                  const timeDiff = Date.now() - gameWorld.timestamp;
                  if (timeDiff < 3000) {
                      updateWorldState(gameWorld);
                  }
              }

              const newHostEvent = localStorage.getItem('gameEvent_new_host');
              if (newHostEvent) {
                  const eventData = JSON.parse(newHostEvent);
                  if (Date.now() - eventData.timestamp < 1000) { // Process only recent events
                      handleGameMessage({ type: 'new_host_elected', hostId: eventData.hostId });
                  }
                  localStorage.removeItem('gameEvent_new_host');
              }

              const levelChangeEvent = localStorage.getItem('gameEvent_level_change');
              if (levelChangeEvent) {
                  const eventData = JSON.parse(levelChangeEvent);
                  if (Date.now() - eventData.timestamp < 1000) { // Process only recent events
                      handleGameMessage({ type: 'level_change', level: eventData.level });
                  }
                  localStorage.removeItem('gameEvent_level_change');
              }

              const gameResetEvent = localStorage.getItem('gameEvent_reset');
              if (gameResetEvent) {
                  const eventData = JSON.parse(gameResetEvent);
                  if (Date.now() - eventData.timestamp < 1000) { // Process only recent events
                      handleGameMessage({ type: 'game_reset' });
                  }
                  localStorage.removeItem('gameEvent_reset');
              }

          } catch (error) {
              console.error('게임 월드 데이터 파싱 오류:', error);
          }
      }

      function electNewHost() {
          clearTimeout(electionTimeout);

          // 이미 호스트가 선출되었거나, 선출 과정 진행 중이면 중단
          if (gameState.hostId) {
              return;
          }

          // 랜덤한 시간(0~1초) 후 자신을 호스트로 선언
          const electionDelay = Math.random() * 1000;
          if (gameState.debug) console.log(`호스트 선출 절차 시작. ${electionDelay.toFixed(0)}ms 후 입후보합니다.`);

          electionTimeout = setTimeout(() => {
              // 그 사이 다른 플레이어가 호스트로 선출되지 않았다면
              if (!gameState.hostId) {
                  console.log('내가 새로운 호스트가 됩니다.');
                  gameState.isHost = true;
                  gameState.hostId = gameState.myPlayerId;

                  // 새로운 호스트가 되었음을 모두에게 알림
                  if (gameChannel) {
                      gameChannel.postMessage({ type: 'new_host_elected', hostId: gameState.hostId });
                  } else {
                      // localStorage 폴백
                      localStorage.setItem('gameEvent_new_host', JSON.stringify({ hostId: gameState.hostId, timestamp: Date.now() }));
                  }
              }
          }, electionDelay);
      }

      function checkForHost() {
          if (gameState.isHost || !gameChannel) return;

          // Check for host every 5 seconds
          setInterval(() => {
              if (!gameState.hostId) {
                  console.log("호스트를 찾을 수 없습니다. 호스트 동기화를 요청합니다.");
                  gameChannel.postMessage({ type: 'request_host_sync' });
                  // Start election process if no host is found after a short delay
                  setTimeout(() => {
                      if (!gameState.hostId) {
                          electNewHost();
                      }
                  }, 2000);
              }
          }, 5000);
      }

      document.addEventListener('keydown', (e) => {
          gameState.keys[e.code] = true;
      });

      document.addEventListener('keyup', (e) => {
          gameState.keys[e.code] = false;
      });

      window.addEventListener('resize', () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
      });

      // 창이 포커스를 잃으면 모든 키 입력을 초기화 (키 씹힘 방지)
      window.addEventListener('blur', () => {
          gameState.keys = {};
      });

      window.addEventListener('beforeunload', () => {
          if (gameState.roomId && gameState.myPlayerId) {a
              localStorage.removeItem('player_' + gameState.myPlayerId);
          }
      });
    </script>
  </body>
</html>
